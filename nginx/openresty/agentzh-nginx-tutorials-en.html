<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>agentzh's Nginx Tutorials (version 2016.07.14)</title>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="tutorial.css"/>
        <script type="text/javascript">

          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-24724965-1']);
          _gaq.push(['_setDomainName', 'openresty.org']);
          _gaq.push(['_trackPageview']);

          var _gaf = (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          });
          setTimeout(_gaf, 0);

        </script>
    </head>
    <body><h1 class="page-title">agentzh's Nginx Tutorials (version 2016.07.14)</h1>
    <section class="toc">
    <h3>Table of Contents</h3>
<ul>
    <li><a href="#00-foreword01">Foreword</a></li>
    <li><a href="#00-foreword02">Writing Plan for the Tutorials</a></li>
    <li><a href="#01-nginxvariables01">Nginx Variables (01)</a></li>
    <li><a href="#01-nginxvariables02">Nginx Variables (02)</a></li>
    <li><a href="#01-nginxvariables03">Nginx Variables (03)</a></li>
    <li><a href="#01-nginxvariables04">Nginx Variables (04)</a></li>
    <li><a href="#01-nginxvariables05">Nginx Variables (05)</a></li>
    <li><a href="#01-nginxvariables06">Nginx Variables (06)</a></li>
    <li><a href="#01-nginxvariables07">Nginx Variables (07)</a></li>
    <li><a href="#01-nginxvariables08">Nginx Variables (08)</a></li>
    <li><a href="#02-nginxdirectiveexecorder01">Nginx Directive Execution Order (01)</a></li>
    <li><a href="#02-nginxdirectiveexecorder02">Nginx Directive Execution Order (02)</a></li>
    <li><a href="#02-nginxdirectiveexecorder03">Nginx Directive Execution Order (03)</a></li>
    <li><a href="#02-nginxdirectiveexecorder04">Nginx Directive Execution Order (04)</a></li>
    <li><a href="#02-nginxdirectiveexecorder05">Nginx Directive Execution Order (05)</a></li>
    <li><a href="#02-nginxdirectiveexecorder06">Nginx Directive Execution Order (06)</a></li>
    <li><a href="#02-nginxdirectiveexecorder07">Nginx Directive Execution Order (07)</a></li>
    <li><a href="#02-nginxdirectiveexecorder08">Nginx Directive Execution Order (08)</a></li>
    <li><a href="#02-nginxdirectiveexecorder09">Nginx Directive Execution Order (09)</a></li>
    <li><a href="#02-nginxdirectiveexecorder10">Nginx Directive Execution Order (10)</a></li>
</ul>
</section>
<section class="content">
<article>
    <h1 class="con-title" id="00-foreword01">Foreword <a class="anchor" href="#00-foreword01">&#61532;</a></h1>
<p>I've been doing a lot of work in the Nginx world over the last few years and I've also been thinking about writing a series of tutorial-like articles to explain to more people what I've done and what I've learned in this area. Now I have finally decided to post serial articles to the Sina Blog <a href="http://blog.sina.com.cn/openresty" target="_blank">http://blog.sina.com.cn/openresty</a> in Chinese. Every article will roughly cover a single topic and will be in a rather casual style. But at some point in the future I may restructure the articles and their style in order to turn them into a "real" book.
</p>
<p>The articles are divided into series. For example, the first series is "Nginx Variables". Each series can be thought of as mapping to a chapter in the Nginx book that I may publish in the future.
</p>
<p>The articles are intended for Nginx users of all experience levels, including users with extensive Apache and Lighttpd experience who may have never used Nginx before.
</p>
<p>The examples in the articles are at least compatible with Nginx <code>0.8.54</code>. Do not try the examples with older versions of Nginx. The latest stable version of Nginx as of this writing is <code>1.7.9</code>.
</p>
<p>All of the Nginx modules referenced in the articles are production-ready. I will not be covering any Nginx core modules that are either experimental or buggy. Additionally, I will be making extensive use of 3rd-party Nginx modules in the examples. If it's inconvenient for you to download and install the individual modules one at a time then I highly recommend that you download and install the <code>ngx_openresty</code> software bundle that I maintain.
</p>
<p><a href="http://openresty.org/" target="_blank">http://openresty.org/</a>
</p>
<p>All of the modules referenced in the articles, including the core Nginx modules that are new (but stable), are included in the OpenResty bundle.
</p>
<p>A principle that I will be trying to adhere to is to use small concise examples to explain and validate the concepts and behaviors being described. My hope is that it will help the reader to develop the good habit of not accepting others' viewpoints or statements at face value without testing them first. This approach may have something to do with my QA background. In fact, I keep tweaking and correcting the articles based on the results of running the examples while writing.
</p>
<p>The examples in the articles fall into one of two categories, good and problematic. The purpose of the problematic examples is to highlight potential pitfalls and other areas where Nginx or its modules behave in ways that readers may not expect. Problematic examples are easy to identify because each line of text in the example will be prefixed with a question mark, i.e., "<code>?</code>". Here is an example:
</p>
<code class="block">?&nbsp;server&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
?<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bad&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$foo;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
?&nbsp;}<br/>
</code><p>Do not reproduce these articles without explicit permissions from us. Copyright reserved.
</p>
<p>I encourage readers to send feedback (<code>agentzh@gmail.com</code>), especially constructive criticism.
</p>
<p>The source for all the articles is on GitHub:
</p>
<p><a href="http://github.com/agentzh/nginx-tutorials/" target="_blank">http://github.com/agentzh/nginx-tutorials/</a>
</p>
<p>The source files are under the <code>en/</code> directory. I am using a little markup language that is a mixture of <code>Wiki</code> and <code>POD</code> to write these articles. They are the <code>.tut</code> files. You are welcome to create forks and/or provide patches.
</p>
<p>The e-books files that are suitable for cellphones, Kindle, iPad/iPhone, Sony Readers, and other devices can be downloaded from here:
</p>
<p><a href="http://openresty.org/#eBooks" target="_blank">http://openresty.org/#eBooks</a>
</p>
<p>Special thanks go to Kai Wu (kai10k) who kindly translates these articles to English.
</p>
<p>agentzh at home in the Fuzhou city
</p>
<p>October 30, 2011</p>
</article>
<article>
    <h1 class="con-title" id="00-foreword02">Writing Plan for the Tutorials <a class="anchor" href="#00-foreword02">&#61532;</a></h1>
<p>Here lists the tutorial series that have already been published or to be published.
</p>
<ul>
<li>Getting Started with Nginx</li>
<li>How Nginx Matches URIs</li>
<li><a href="#01-nginxvariables01">Nginx Variables</a></li>
<li><a href="#02-nginxdirectiveexecorder01">Nginx Directive Execution Order</a></li>
<li>Nginx's if is Evil</li>
<li>Nginx Subrequests</li>
<li>Nginx Static File Services</li>
<li>Nginx Log Services</li>
<li>Application Gateways based on Nginx</li>
<li>Reverse-Proxies based on Nginx</li>
<li>Nginx and Memcached</li>
<li>Nginx and Redis</li>
<li>Nginx and MySQL</li>
<li>Nginx and PostgreSQL</li>
<li>Application caching Based on Nginx</li>
<li>Security and Access Control in Nginx</li>
<li>Web Services Based on Nginx</li>
<li>AJAX Applications Driven by Nginx</li>
<li>Performance Testing for Nginx and its Applications</li>
<li>Strength of the Nginx Community</li>
</ul>
<p>The series names can roughly correspond to the chapter names in my final Nginx book, but they are unlikely to stay exactly the same. The actual series names may change and the relative order of the series may change as well.
</p>
<p>The list above will be constantly updated to always reflect the latest plan.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables01">Nginx Variables (01) <a class="anchor" href="#01-nginxvariables01">&#61532;</a></h1>
    <h2 class="con-title" id="nginx-variables-variables-as-value-containers">Variables as Value Containers <a class="anchor" href="#nginx-variables-variables-as-value-containers">&#61532;</a></h2>
<p>Nginx's configuration files use a micro programming language. Many real-world Nginx configuration files are essentially small programs. This language's design is heavily influenced by Perl and Bourne Shell as far as I can see, despite the fact that it might not be Turing-Complete and it is declarative in many places. This is a distinguishing feature of Nginx, as compared to other web servers like Apache or Lighttpd. Being a programming language, "variables" are thus a natural part of it (exceptions do exist, of course, as in pure functional languages like Haskell).
</p>
<p><div class="thumb tright">
               <div class="thumbinner" style="width:222px;">
                <img class="thumbimage" width="220" src="image/value-container.jpg">
                <div class="thumbcaption">
                    <div class="magnify">Variables are value containers</div>
                </div>
               </div>
            </div>
</p>
<p>Variables are just containers holding various values in imperative languages like Perl, Bourne Shell, and C/C++. And "values" can be numbers like <code>3.14</code>, strings like <code>hello world</code>, or even complicated things like references to arrays or hash tables in those languages. For the Nginx configuration language, however, variables can hold only one type of values, that is, strings (there is an interesting exception: the 3rd-party module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> extends Nginx variables to hold arrays, but it is implemented by encoding a C pointer as a binary string value behind the scene).
</p>
    <h2 class="con-title" id="nginx-variables-variable-syntax-and-interpolation">Variable Syntax and Interpolation <a class="anchor" href="#nginx-variables-variable-syntax-and-interpolation">&#61532;</a></h2>
<p>Let's say our <code>nginx.conf</code> configuration file has the following line:
</p>
<code class="block">set&nbsp;$a&nbsp;&quot;hello&nbsp;world&quot;;<br/>
</code><p>We assign a value to the variable <code>$a</code> via the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> configuration directive coming from the standard  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> module. In particular, we assign the string value <code>hello world</code> to <code>$a</code>.
</p>
<p>We can see that the Nginx variable name takes a dollar sign (<code>$</code>) in front of it. This is required by the language syntax: whenever we want to reference an Nginx variable in the configuration file, we must add a <code>$</code> prefix. This looks very familiar to those Perl and PHP programmers.
</p>
<p>Such variable prefix modifiers may discomfort some Java and C# programmers, this notation does have an obvious advantage though, that is, variables can be embedded directly into a string literal:
</p>
<code class="block">set&nbsp;$a&nbsp;hello;<br/>
set&nbsp;$b&nbsp;&quot;$a,&nbsp;$a&quot;;<br/>
</code><p>Here we use the value of the existing Nginx variable <code>$a</code> to construct the value for the variable <code>$b</code>. So after these two directives complete execution, the value of <code>$a</code> is <code>hello</code>, and <code>$b</code> is <code>hello, hello</code>. This technique is called "variable interpolation" in the Perl world, which makes ad-hoc string concatenation operators no longer that necessary. Let's use the same term for the Nginx world from now on.
</p>
<p>Let's see another complete example:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;hello;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo:&nbsp;$foo&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>This example omits the <code>http</code> directive and <code>events</code> configuration blocks in the outer-most scope for brevity. To request this <code>/test</code> interface via <code>curl</code>, an HTTP client utility, on the command line, we get
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
foo:&nbsp;hello<br/>
</code><p>Here we use the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive of the 3rd party module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> to print out the value of the <code>$foo</code> variable as the HTTP response.
</p>
<p>Apparently the arguments of the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive does support "variable interpolation", but we can not take it for granted for other directives. Because not all the configuration directives support "variable interpolation" and it is in fact up to the implementation of the directive in that module. Always look up the documentation to be sure.
</p>
    <h3 class="con-title" id="nginx-variables-escaping-dollar">Escaping "$" <a class="anchor" href="#nginx-variables-escaping-dollar">&#61532;</a></h3>
<p>We've already learned that the <code>$</code> character is special and it serves as the variable name prefix, but now consider that we want to output a literal <code>$</code> character via the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive. The following naive example does not work at all:
</p>
<code class="block">?&nbsp;:nginx<br/>
?&nbsp;location&nbsp;/t&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;$&quot;;<br/>
?&nbsp;}<br/>
</code><p>We will get the following error message while loading this configuration:
</p>
<code class="block">[emerg]&nbsp;invalid&nbsp;variable&nbsp;name&nbsp;in&nbsp;...<br/>
</code><p>Obviously Nginx tries to parse <code>$"</code> as a variable name. Is there a way to escape <code>$</code> in the string literal? The answer is "no" (it is still the case in the latest Nginx stable release <code>1.2.7</code>) and I have been hoping that we could write something like <code>$$</code> to obtain a literal <code>$</code>.
</p>
<p>Luckily, workarounds do exist and here is one proposed by Maxim Dounin: first we assign to a variable a literal string containing a dollar sign character via a configuration directive that does <I>not</I> support "variable interpolation" (remember that not all the directives support "variable interpolation"?), and then reference this variable later whenever we need a dollar sign. Here is such an example to demonstrate the idea:
</p>
<code class="block">geo&nbsp;$dollar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&quot;$&quot;;<br/>
}<br/>
<br/>
server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;This&nbsp;is&nbsp;a&nbsp;dollar&nbsp;sign:&nbsp;$dollar&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Let's test it out:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
This&nbsp;is&nbsp;a&nbsp;dollar&nbsp;sign:&nbsp;$<br/>
</code><p>Here we make use of the  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> directive of the standard module  <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank">ngx_geo</a> to initialize the <code>$dollar</code> variable with the string <code>"$"</code>, thereafter variable <code>$dollar</code> can be used in places that require a dollar sign. This works because the  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> directive does not support "variable interpolation" at all. However, the  <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank">ngx_geo</a> module is originally designed to set a Nginx variable to different values according to the remote client address, and in this example, we just abuse it to initialize the <code>$dollar</code> variable with the string <code>"$"</code> unconditionally.
</p>
    <h3 class="con-title" id="nginx-variables-disambiguating-variable-names">Disambiguating Variable Names <a class="anchor" href="#nginx-variables-disambiguating-variable-names">&#61532;</a></h3>
<p>There is a special case for "variable interpolation", that is, when the variable name is followed directly by characters allowed in variable names (like letters, digits, and underscores). In such cases, we can use a special notation to disambiguate the variable name from the subsequent literal characters, for instance,
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$first&nbsp;&quot;hello&nbsp;&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;${first}world&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Here the variable <code>$first</code> is concatenated with the literal string <code>world</code>. If it were written directly as <code>"$firstworld"</code>, Nginx's "variable interpolation" engine (also known as the "script engine") would try to access the variable <code>$firstworld</code> instead of <code>$first</code>. To resolve the ambiguity here, curly braces must be used around the variable name (excluding the <code>$</code> prefix), as in <code>${first}</code>. Let's test this sample:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test<br/>
hello&nbsp;world<br/>
</code>    <h2 class="con-title" id="nginx-variables-variable-declaration-and-creation">Variable Declaration and Creation <a class="anchor" href="#nginx-variables-variable-declaration-and-creation">&#61532;</a></h2>
<p>In languages like C/C++, variables must be declared (or created) before they can be used so that the compiler can allocate storage and perform type checking at compile-time. Similarly, Nginx creates all the Nginx variables while loading the configuration file (or in other words, at "configuration time"), therefore Nginx variables are also required to be declared somehow.
</p>
<p>Fortunately the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive and the  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> directive mentioned above do have the side effect of declaring or creating Nginx variables that they will assign values to later at "request time". If we do not declare a variable this way and use it directly in, say, the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive, we will get an error. For example,
</p>
<code class="block">?&nbsp;server&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
?<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bad&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$foo;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
?&nbsp;}<br/>
</code><p>Here we do not declare the <code>$foo</code> variable and access its value directly in  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. Nginx will just refuse loading this configuration:
</p>
<code class="block">[emerg]&nbsp;unknown&nbsp;&quot;foo&quot;&nbsp;variable<br/>
</code><p>Yes, we cannot even start the server!
</p>
<p>Nginx variable creation and assignment happen at completely different phases along the time-line. Variable creation only occurs when Nginx loads its configuration. On the other hand, variable assignment occurs when requests are actually being served. This also means that we can never create new Nginx variables at "request time".
</p>
    <h2 class="con-title" id="nginx-variables-variable-scope">Variable Scope <a class="anchor" href="#nginx-variables-variable-scope">&#61532;</a></h2>
<p>Once an Nginx variable is created, it is visible to the entire configuration, even across different virtual server configuration blocks, regardless of the places it is declared at. Here is an example:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo&nbsp;=&nbsp;[$foo]&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo&nbsp;=&nbsp;[$foo]&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Here the variable <code>$foo</code> is created by the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive within <code>location /bar</code>, and this variable is visible to the entire configuration, therefore we can reference it in <code>location /foo</code> without worries. Below is the result of testing these two interfaces via the <code>curl</code> tool.
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br/>
foo&nbsp;=&nbsp;[]<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/bar'<br/>
foo&nbsp;=&nbsp;[32]<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br/>
foo&nbsp;=&nbsp;[]<br/>
</code><p>We can see that the assignment operation is only performed in requests that access <code>location /bar</code>, since the corresponding  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive is only used in that location. When requesting the <code>/foo</code> interface, we always get an empty value for the <code>$foo</code> variable because that is what we get when accessing an uninitialized variable.
</p>
<p>Another important characteristic that we can observe from this example is that even though the scope of Nginx variables is the entire configuration, each request does have its own version of all those variables' containers. Requests do not interfere with each other even if they are referencing a variable with the same name. This is very much like local variables in C/C++ function bodies. Each invocation of the C/C++ function does use its own version of those local variables (on the stack).
</p>
<p>For instance, in this sample, we request <code>/bar</code> and the variable <code>$foo</code> gets the value <code>32</code>, which does not affect the value of <code>$foo</code> in subsequent requests to <code>/foo</code> (it is still uninitialized!), because they correspond to different value containers.
</p>
<p>One common mistake for Nginx newcomers is to regard Nginx variables as something shared among all the requests. Even though the scope of Nginx variable <I>names</I> go across configuration blocks at "configuration time", its <I>value container</I>'s scope never goes beyond request boundaries at "request time". Essentially here we do have two different kinds of scope here.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables02">Nginx Variables (02) <a class="anchor" href="#01-nginxvariables02">&#61532;</a></h1>
    <h2 class="con-title" id="nginx-variables-variable-lifetime-and-internal-redirection">Variable Lifetime & Internal Redirection <a class="anchor" href="#nginx-variables-variable-lifetime-and-internal-redirection">&#61532;</a></h2>
<p>We already know that Nginx variables are bound to each request handled by Nginx, for this reason they have exactly the same lifetime as the corresponding request.
</p>
<p>There is another common misunderstanding here though: some newcomers tend to assume that the lifetime of Nginx variables is bound to the <code>location</code> configuration block. Let's consider the following counterexample:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_exec&nbsp;/bar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;a&nbsp;=&nbsp;[$a]&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Here in <code>location /foo</code> we use the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> directive (provided by the 3rd-party module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>) to initiate an "internal redirection" to <code>location /bar</code>. The "internal redirection" is an operation that makes Nginx jump from one <code>location</code> to another while processing a request. This "jumping" happens completely within the server itself. This is different from those "external redirections" based on the HTTP <code>301</code> and <code>302</code> responses because the latter is collaborated externally, by the HTTP clients. Also, in case of "external redirections", the end user could usually observe the change of the URL in her web browser's address bar while this is not the case for internal ones. "Internal redirections" are very similar to the <code>exec</code> command in Bourne Shell; it is a "one way trip" and never returns. Another similar example is the <code>goto</code> statement in the C language.
</p>
<p>Being an "internal redirection", the request after the redirection remains the original one. It is just the current <code>location</code> that is changed, so we are still using the original copy of the Nginx variable containers. Back to our example, the whole process looks like this: Nginx first assigns to the <code>$a</code> variable the string value <code>hello</code> via the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive in <code>location /foo</code>, and then it issues an internal redirection via the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> directive, thus leaving <code>location /foo</code> and entering <code>location /bar</code>, and finally it outputs the value of <code>$a</code>. Because the value container of <code>$a</code> remains untouched, we can expect the response output to be <code>hello</code>. The test result confirms this:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/foo<br/>
a&nbsp;=&nbsp;[hello]<br/>
</code><p>But when accessing <code>/bar</code> directly from the client side, we will get an empty value for the <code>$a</code> variable, since this variable relies on <code>location /foo</code> to get initialized.
</p>
<p>It can be observed that during a request's lifetime, the copy of Nginx variable containers does not change at all even when Nginx goes across different <code>location</code> configuration blocks. Here we also encounter the concept of "internal redirections" for the first time and it's worth mentioning that the  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> directive of the  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> module can also be used to initiate "internal redirections". For instance, we can rewrite the example above with the  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> directive as follows:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/bar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;a&nbsp;=&nbsp;[$a]&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>It's functionally equivalent to  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a>. We will discuss the  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> directive in more depth in later chapters, like initiating "external redirections" like <code>301</code> and <code>302</code>.
</p>
<p>To conclude, the lifetime of Nginx variable containers is indeed bound to the request being processed, and is irrelevant to <code>location</code>.
</p>
    <h2 class="con-title" id="nginx-variables-nginx-built-in-variables">Nginx Built-in Variables <a class="anchor" href="#nginx-variables-nginx-built-in-variables">&#61532;</a></h2>
<p>The Nginx variables we have seen so far are all (implicitly) created by directives like  <a href="http://wiki.nginx.org/HttpRewiteModule#set" target="_blank">set</a>. We usually call such variables "user-defined varaibles", or simply "user variables". There is also another kind of Nginx variables that are <I>pre-defined</I> by either the Nginx core or Nginx modules. Let's call this kind of variables "built-in variables".
</p>
    <h3 class="con-title" id="nginx-variables-dollar-uri-and-dollar-request_uri">$uri & $request_uri <a class="anchor" href="#nginx-variables-dollar-uri-and-dollar-request_uri">&#61532;</a></h3>
<p>One common use of Nginx built-in variables is to retrieve various types of information about the current request or response. For instance, the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> provided by <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a> is used to fetch the (decoded) URI of the current request, excluding any query string arguments. Another example is the  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a> variable provided by the same module, which is used to fetch the raw, non-decoded form of the URI, including any query string. Let's look at the following example.
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;uri&nbsp;=&nbsp;$uri&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;request_uri&nbsp;=&nbsp;$request_uri&quot;;<br/>
}<br/>
</code><p>We omit the <code>server</code> configuration block here for brevity. Just as all those samples above, we still listen to the <code>8080</code> local port. In this example, we output both the  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> and  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a> into the response body. Below is the result of testing this <code>/test</code> interface with different requests:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
uri&nbsp;=&nbsp;/test<br/>
request_uri&nbsp;=&nbsp;/test<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test?a=3&amp;b=4'<br/>
uri&nbsp;=&nbsp;/test<br/>
request_uri&nbsp;=&nbsp;/test?a=3&amp;b=4<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test/hello%20world?a=3&amp;b=4'<br/>
uri&nbsp;=&nbsp;/test/hello&nbsp;world<br/>
request_uri&nbsp;=&nbsp;/test/hello%20world?a=3&amp;b=4<br/>
</code>    <h3 class="con-title" id="nginx-variables-variables-with-infinite-names">Variables with Infinite Names <a class="anchor" href="#nginx-variables-variables-with-infinite-names">&#61532;</a></h3>
<p>There is another very common built-in variable that does not have a fixed variable name. Instead, It has <I>infinite</I> variations. That is, all those variables whose names have the prefix <code>arg_</code>, like <code>$arg_foo</code> and <code>$arg_bar</code>. Let's just call it the  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> "variable group". For example, the <code>$arg_name</code> variable is evaluated to the value of the <code>name</code> URI argument for the current request. Also, the URI argument's value obtained here is not decoded yet, potentially containing the <code>%XX</code> sequences. Let's check out a complete example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;name:&nbsp;$arg_name&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;class:&nbsp;$arg_class&quot;;<br/>
}<br/>
</code><p>Then we test this interface with various different URI argument combinations:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
name:<br/>
class:<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test?name=Tom&amp;class=3'<br/>
name:&nbsp;Tom<br/>
class:&nbsp;3<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test?name=hello%20world&amp;class=9'<br/>
name:&nbsp;hello%20world<br/>
class:&nbsp;9<br/>
</code><p>In fact, <code>$arg_name</code> does not only match the <code>name</code> argument name, but also <code>NAME</code> or even <code>Name</code>. That is, the letter case does not matter here:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?NAME=Marry'<br/>
name:&nbsp;Marry<br/>
class:<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test?Name=Jimmy'<br/>
name:&nbsp;Jimmy<br/>
class:<br/>
</code><p>Behind the scene, Nginx just converts the URI argument names into the pure lower-case form before matching against the name specified by  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>.
</p>
<p>If you want to decode the special sequences like <code>%20</code> in the URI argument values, then you could use the  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> directive provided by the 3rd-party module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a>.
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$name&nbsp;$arg_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$class&nbsp;$arg_class;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;name:&nbsp;$name&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;class:&nbsp;$class&quot;;<br/>
}<br/>
</code><p>Let's check out the actual effect:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?name=hello%20world&amp;class=9'<br/>
name:&nbsp;hello&nbsp;world<br/>
class:&nbsp;9<br/>
</code><p>The space has indeed been decoded!
</p>
<p>Another thing that we can observe from this example is that the  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> directive can also implicitly create Nginx user-defined variables, just like the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive. We will discuss the  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> module in more detail in future chapters.
</p>
<p>This type of variables like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> possesses infinite number of possible names, so they do not correspond to any value containers. Furthermore, such variables are handled in a very specific way within the Nginx core. It is thus not possible for 3rd-party modules to introduce such magical built-in variables of their own.
</p>
<p>The Nginx core offers a lot of such built-in variables in addition to  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>, like the  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a> variable group for fetching HTTP cookie values, the  <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank">$http_XXX</a> variable group for fetching request headers, as well as the  <a href="http://wiki.nginx.org/HttpCoreModule#.24sent_http_HEADER" target="_blank">$sent_http_XXX</a> variable group for retrieving response headers. We will not go into the details for each of them here. Interested readers can refer to the official documentation for the <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a> module.
</p>
    <h3 class="con-title" id="nginx-variables-read-only-built-in-variables">Read-only Built-in Variables <a class="anchor" href="#nginx-variables-read-only-built-in-variables">&#61532;</a></h3>
<p>All the user-defined variables are writable. Actually the way that we declare or create such variables so far is to use a configure directive, like  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>, that performs value assignment at request time. But it is <I>not</I> necessarily the case for built-in variables.
</p>
<p>Most of the built-in variables are effectively <I>read-only</I>, like the  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> and  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a> variables that we just introduced earlier. Assignments to such read-only variables must always be avoided. Otherwise it will lead to unexpected consequences, for example,
</p>
<code class="block">?&nbsp;location&nbsp;/bad&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$uri&nbsp;/blah;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$uri;<br/>
?&nbsp;}<br/>
</code><p>This problematic configuration just triggers a confusing error message when Nginx is started:
</p>
<code class="block">[emerg]&nbsp;the&nbsp;duplicate&nbsp;&quot;uri&quot;&nbsp;variable&nbsp;in&nbsp;...<br/>
</code><p>Attempts of writing to some other read-only built-in variables like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> will just lead to server crashes in some particular Nginx versions.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables03">Nginx Variables (03) <a class="anchor" href="#01-nginxvariables03">&#61532;</a></h1>
    <h3 class="con-title" id="nginx-variables-writable-built-in-variable-dollar-args">Writable Built-in Variable $args <a class="anchor" href="#nginx-variables-writable-built-in-variable-dollar-args">&#61532;</a></h3>
<p>Some built-in variables are writable as well. For instance, when reading the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, we get the URL query string of the current request, but when writing to it, we are effectively modifying the query string. Here is such an example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$orig_args&nbsp;$args;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;&quot;a=3&amp;b=4&quot;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;original&nbsp;args:&nbsp;$orig_args&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;args:&nbsp;$args&quot;;<br/>
}<br/>
</code><p>Here we first save the original URL query string into our own variable <code>$orig_args</code>, then modify the current query string by overriding the  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> variable, and finally output the variables <code>$orig_args</code> and  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, respectively, with the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive. Let's test it like this:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
original&nbsp;args:<br/>
args:&nbsp;a=3&amp;b=4<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test?a=0&amp;b=1&amp;c=2'<br/>
original&nbsp;args:&nbsp;a=0&amp;b=1&amp;c=2<br/>
args:&nbsp;a=3&amp;b=4<br/>
</code><p>In the first test, we did not provide any URL query string, hence the empty output for the <code>$orig_args</code> variable. And in both tests, the current query string was forcibly overridden to the new value <code>a=3&b=4</code>, regardless of the presence of a query string in the original request.
</p>
<p>It should be noted that the  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> variable here no longer owns a value container as user variables, just like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>. When reading  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, Nginx will execute a special piece of code, fetching data from a particular place where the Nginx core stores the URL query string for the current request. On the other hand, when we overwrite  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, Nginx will execute another special piece of code, storing new value into the same place in the core. Other parts of Nginx also read the same place whenever the query string is needed, so our modification to  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> will immediately affect all the other parts' functionality later on. Let's see an example for this:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$orig_a&nbsp;$arg_a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;&quot;a=5&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;original&nbsp;a:&nbsp;$orig_a&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;a:&nbsp;$arg_a&quot;;<br/>
}<br/>
</code><p>Here we first save the value of the built-in varaible <code>$arg_a</code>, the value of the original request's URL argument <code>a</code>, into our user variable <code>$orig_a</code>, then change the URL query string to <code>a=5</code> by assigning the new value to the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, and finally output the variables <code>$orig_a</code> and <code>$arg_a</code>, respectively. Because modifications to  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> effectively change the URL query string of the current request for the whole server, the value of the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> should also change accordingly. The test result verifies this:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?a=3'<br/>
original&nbsp;a:&nbsp;3<br/>
a:&nbsp;5<br/>
</code><p>We can see that the initial value of <code>$arg_a</code> is <code>3</code> since the URL query string of the original request is <code>a=3</code>. But the final value of <code>$arg_a</code> automatically becomes <code>5</code> after we modify  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> with the value <code>a=5</code>.
</p>
<p>Below is another example to demonstrate that assignments to <code>$args</code> also affect the HTTP proxy module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a>.
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;&quot;foo=1&amp;bar=2&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://127.0.0.1:8081/args;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
<br/>
server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8081;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/args&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;args:&nbsp;$args&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Two virtual servers are defined here in the <code>http</code> configuration block (omitted for brevity).
</p>
<p>The first virtual server is listening at the local port 8080. Its <code>/test</code> location first updates the current URL query string to the value <code>foo=1&bar=2</code> by writing to  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, then sets up an HTTP reverse proxy via the  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> directive of the  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> module, targeting the HTTP service <code>/args</code> on the local port 8081. By default the  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> module automatically forwards the current URL query string to the remote HTTP service.
</p>
<p>The "remote HTTP service" on the local port 8081 is provided by the second virtual server defined by ourselves, where we output the current URL query string via the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive in <code>location /args</code>. By doing this, we can investigate the actual URL query string forwarded by the  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> module from the first virtual server.
</p>
<p>Let's access the <code>/test</code> interface exposed by the first virtual server.
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?blah=7'<br/>
args:&nbsp;foo=1&amp;bar=2<br/>
</code><p>We can see that the URL query string is first rewritten to <code>foo=1&bar=2</code> even though the original request takes the value <code>blah=7</code>, then it is forwarded to the <code>/args</code> interface of the second virtual server via the  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> directive, and finally its value is output to the client.
</p>
<p>To summarize, the assignment to  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> also successfully influences the behavior of the  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> module.
</p>
    <h2 class="con-title" id="nginx-variables-variable-get-handlers-and-set-handlers">Variable "Get Handlers" and "Set Handlers" <a class="anchor" href="#nginx-variables-variable-get-handlers-and-set-handlers">&#61532;</a></h2>
<p>We have already learned in previous sections that when reading the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, Nginx executes a special piece of code to obtain a value on-the-fly and when writing to this variable, Nginx executes another special piece of code to propagate the change. In Nginx's terminology, the special code executed for reading the variable is called "get handler" and the code for writing to the variable is called "set handler". Different Nginx modules usually prepare different "get handlers" and "set handlers" for their own variables, which effectively put magic into these variables' behavior.
</p>
<p>Such techniques are not uncommon in the computing world. For example, in object-oriented programming (OOP), the class designer usually does not expose the member variable of the class directly to the user programmer, but instead provides two methods for reading from and writing to the member variable, respectively. Such class methods are often called "accessors". Below is an example in the C++ programming language:
</p>
<code class="block">#include&nbsp;&lt;string&gt;<br/>
using&nbsp;namespace&nbsp;std;<br/>
<br/>
class&nbsp;Person&nbsp;{<br/>
public:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;string&nbsp;get_name()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;set_name(const&nbsp;string&nbsp;name)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_name&nbsp;=&nbsp;name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
private:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;m_name;<br/>
};<br/>
</code><p>In this C++ class <code>Person</code>, we provide two public methods, <code>get_name</code> and <code>set_name</code>, to serve as the "accessors" for the private member variable <code>m_name</code>.
</p>
<p>The benefits of such design are obvious. The class designer can execute arbitrary code in the "accessors", to implement any extra business logic or useful side effects, like automatically updating other member variables depending on the current member, or updating the corresponding field in a database associated with the current object. For the latter case, it is possible that the member variable does not exist at all, or that the member variable just serves as a data cache to mitigate the pressure on the back-end database.
</p>
<p>Corresponding to the concept of "accessors" in OOP, Nginx variables also support binding custom "get handlers" and "set handlers". Additionally, not all Nginx variables own a container to hold values. Some variables without a container just behave like a magical container by means of its fancy "get handler" and "set handler". In fact, when a variable is being created at "configure time", the creating Nginx module must make a decision on whether to allocate a value container for it and whether to attach a custom "get handler" and/or a "set handler" to it.
</p>
<p>Those variables owning a value container are called "indexed variables" in Nginx's terminology. Otherwise, they are said to be not indexed.
</p>
<p>We already know that the "variable groups" like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> discussed in earlier sections do not have a value container and thus are not indexed. When reading  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>, it is its "get handler" at work, that is, its "get handler" scans the current URL query string on-the-fly, extracting the value of the specified URL argument. Many beginners misunderstand the way  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> is implemented; they assume that Nginx will parse all the URL arguments in advance and prepare the values for all those non-empty  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variables before they are actually read. This is not true, however. Nginx never tries to parse all the URL arguments beforehand, but rather scans the whole URL query string for a particular argument in a "get handler" every time that argument is requested by reading the corresponding  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variable. Similarly, when reading the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a>, its "get handler" just scans the <code>Cookie</code> request headers for the cookie name specified.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables04">Nginx Variables (04) <a class="anchor" href="#01-nginxvariables04">&#61532;</a></h1>
    <h2 class="con-title" id="nginx-variables-value-containers-for-caching-and-ngx_map">Value Containers for Caching & ngx_map <a class="anchor" href="#nginx-variables-value-containers-for-caching-and-ngx_map">&#61532;</a></h2>
<p>Some Nginx variables choose to use their value containers as a data cache when the "get handler" is configured. In this setting, the "get handler" is run only once, i.e., at the first time the variable is read, which reduces overhead when the variable is read multiple times during its lifetime. Let's see an example for this.
</p>
<code class="block">map&nbsp;$args&nbsp;$foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
}<br/>
<br/>
server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$orig_foo&nbsp;$foo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;debug;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;original&nbsp;foo:&nbsp;$orig_foo&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo:&nbsp;$foo&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Here we use the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive from the standard module  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> for the first time, which deserves some introduction. The word <code>map</code> here means mapping or correspondence. For example, functions in Maths are a kind of "mapping". And Nginx's  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive is used to define a "mapping" relationship between two Nginx variables, or in other words, "function relationship". Back to this example, we use the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive to define the "mapping" relationship between user variable <code>$foo</code> and built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>. When using the Math function notation, <code>y = f(x)</code>, our <code>$args</code> variable is effectively the "independent variable", <code>x</code>, while <code>$foo</code> is the "dependent variable", <code>y</code>. That is, the value of <code>$foo</code> depends on the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, or rather, we <I>map</I> the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> onto the <code>$foo</code> variable (in some way).
</p>
<p>Now let's look at the exact mapping rule defined by the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive in this example.
</p>
<code class="block">map&nbsp;$args&nbsp;$foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
}<br/>
</code><p>The first line within the curly braces is a special rule condition, that is, this condition holds if and only if other conditions all fail. When this "default" condition holds, the "dependent variable" <code>$foo</code> is assigned by the value <code>0</code>. The second line within the curly braces means that the "dependent variable" <code>$foo</code> is assigned by the value <code>1</code> if the "independent variable" <code>$args</code> matches the string value <code>debug</code>. Combining these two lines, we obtain the following complete mapping rule: if the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is <code>debug</code>, variable <code>$foo</code> gets the value <code>1</code>; otherwise <code>$foo</code> gets the value <code>0</code>. So essentially, this is a conditional assignment to the variable <code>$foo</code>.
</p>
<p>Now that we understand what the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive does, let's look at the definition of <code>location /test</code>. We first save the value of <code>$foo</code> into another user variable <code>$orig_foo</code>, then overwrite the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> to <code>debug</code>, and finally output the values of <code>$orig_foo</code> and <code>$foo</code>, respectively.
</p>
<p>Intuitively, after we overwrite the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> to <code>debug</code>, the value of <code>$foo</code> should automatically get adjusted to <code>1</code> according to the mapping rule defined earlier, regardless of the original value of <code>$foo</code>. But the test result suggests the other way around.
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
original&nbsp;foo:&nbsp;0<br/>
foo:&nbsp;0<br/>
</code><p>The first output line indicates that the value of <code>$orig_foo</code> is <code>0</code>, which is exactly what we expected: the original request does not take a URL query string, so the initial value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is empty, leading to the <code>0</code> initial value of <code>$foo</code>, according to the "default" condition in our mapping rule.
</p>
<p>But surprisingly, the second output line indicates that the final value of <code>$foo</code> is still <code>0</code>, even after we overwrite  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> to the value <code>debug</code>. This apparently violates our mapping rule because when  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> takes the value <code>debug</code>, the value of <code>$foo</code> should really be <code>1</code>. So what is happening here?
</p>
<p>Actually the reason is pretty simple: when the first time variable <code>$foo</code> is read, its value computed by  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a>'s "get handler" is cached in its value container. We already learned earlier that Nginx modules may choose to use the value container of the variable created by themselves as a data cache for its "get handler". Obviously, the  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> module considers the mapping computation between variables expensive enough and caches the result automatically, so that the next time the same variable is read within the lifetime of the current request, Nginx can just return the cached result without invoking the "get handler" again.
</p>
<p>To verify this further, we can try specifying the URL query string as <code>debug</code> in the original request.
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?debug'<br/>
original&nbsp;foo:&nbsp;1<br/>
foo:&nbsp;1<br/>
</code><p>It can be seen that the value of <code>$orig_foo</code> becomes <code>1</code>, complying with our mapping rule. And subsequent readings of <code>$foo</code> always yield the same cached result, <code>1</code>, regardless of the new value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> later on.
</p>
<p>The  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive is actually a unique example, because it not only registers a "get handler" for the user variable, but also allows the user to define the computing rule in the "get handler" directly in the Nginx configuration file. Of course, the rule that can be defined here is limited to simple mapping relations with another variable. Meanwhile, it must be made clear that not all the variables using a "get handler" will cache the result. For instance, we have already seen earlier that the  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variable does not use its value container at all.
</p>
<p>Similar to the  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> module, the standard module  <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank">ngx_geo</a> that we encountered earlier also enables value caching for the variables created by its  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> directive.
</p>
    <h3 class="con-title" id="nginx-variables-a-side-note-for-use-contexts-of-directives">A Side Note for Use Contexts of Directives <a class="anchor" href="#nginx-variables-a-side-note-for-use-contexts-of-directives">&#61532;</a></h3>
<p>In the previous example, we should also note that the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive is put outside the <code>server</code> configuration block, that is, it is defined directly within the outermost <code>http</code> configuration block. Some readers may be curious about this setting, since we only use it in <code>location /test</code> after all. If we try putting the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> statement within the <code>location</code> block, however, we will get the following error while starting Nginx:
</p>
<code class="block">[emerg]&nbsp;&quot;map&quot;&nbsp;directive&nbsp;is&nbsp;not&nbsp;allowed&nbsp;here&nbsp;in&nbsp;...<br/>
</code><p>So it is explicitly prohibited. In fact, it is only allowed to use the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive in the <code>http</code> block. Every configure directive does have a pre-defined set of use contexts in the configuration file. When in doubt, always refer to the corresponding documentation for the exact use contexts of a particular directive.
</p>
    <h2 class="con-title" id="nginx-variables-lazy-evaluation-of-variable-values">Lazy Evaluation of Variable Values <a class="anchor" href="#nginx-variables-lazy-evaluation-of-variable-values">&#61532;</a></h2>
<p>Many Nginx freshmen would worry that the use of the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive within the global scope (i.e., the <code>http</code> block) will lead to unnecessary variable value computation and assignment for all the <code>location</code>s in all the virtual servers even if only one <code>location</code> block actually uses it. Fortunately, this is <I>not</I> what is happening here. We have already learned how the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive works. It is the "get handler" (registered by the  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> module) that performs the value computation and related assignment. And the "get handler" will not run at all unless the corresponding user variable is actually being read. Therefore, for those requests that never access that variable, there cannot be any (useless) computation involved.
</p>
<p>The technique that postpones the value computation off to the point where the value is actually needed is called "lazy evaluation" in the computing world. Programming languages natively offering "lazy evaluation" is not very common though. The most famous example is the Haskell programming language, where lazy evaluation is the default semantics. In contrast with "lazy evaluation", it is much more common to see "eager evaluation". We are lucky to see examples of lazy evaluation here in the  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> module, but the "eager evaluation" semantics is also much more common in the Nginx world. Consider the following  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> statement that cannot be simpler:
</p>
<code class="block">set&nbsp;$b&nbsp;&quot;$a,$a&quot;;<br/>
</code><p>When running the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive, Nginx eagerly computes and assigns the new value for the variable <code>$b</code> without postponing to the point when <code>$b</code> is actually read later on. Similarly, the  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> directive also evaluates eagerly.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables05">Nginx Variables (05) <a class="anchor" href="#01-nginxvariables05">&#61532;</a></h1>
    <h2 class="con-title" id="nginx-variables-variables-in-subrequests">Variables in Subrequests <a class="anchor" href="#nginx-variables-variables-in-subrequests">&#61532;</a></h2>
    <h3 class="con-title" id="nginx-variables-a-detour-to-subrequests">A Detour to Subrequests <a class="anchor" href="#nginx-variables-a-detour-to-subrequests">&#61532;</a></h3>
<p>We have seen earlier that the lifetime of variable containers is bound to the request, but I own you a formal definition of "requests" there. You might have assumed that the "requests" in that context are just those HTTP requests initiated from the client side. In fact, there are two kinds of "requests" in the Nginx world. One is called "main requests", and the other is called "subrequests".
</p>
<p>Main requests are those initiated externally by HTTP clients. All the examples that we have seen so far involve main requests only, including those doing "internal redirections" via the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> or  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> directive.
</p>
<p>Whereas subrequests are a special kind of requests initiated from within the Nginx core. But please do not confuse subrequests with those HTTP requests created by the  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> modules! Subrequests may look very much like an HTTP request in appearance, their implementation, however, has nothing to do with neither the HTTP protocol nor any kind of socket communication. A subrequest is an abstract invocation for decomposing the task of the main request into smaller "internal requests" that can be served independently by multiple different <code>location</code> blocks, either in series or in parallel. "Subrequests" can also be recursive: any subrequest can initiate more sub-subrequests, targeting other <code>location</code> blocks or even the current <code>location</code> itself. According to Nginx's terminology, if request A initiates a subrequest B, then A is called the "parent request" of B. It is worth mentioning that the Apache web server also has the concept of subrequests for long, so readers coming from that world should be no stranger to this.
</p>
<p>Let's check out an example using subrequests:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/foo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/bar;<br/>
}<br/>
<br/>
location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;foo;<br/>
}<br/>
<br/>
location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;bar;<br/>
}<br/>
</code><p>Here in <code>location /main</code>, we use the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> directive from the  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> module to initiate two <code>GET</code>-typed subrequests targeting <code>/foo</code> and <code>/bar</code>, respectively. The subrequests initiated by  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> are always running sequentially according to their literal order in the configuration file. Therefore, the second <code>/bar</code> request will not be fired until the first <code>/foo</code> request completes processing. The response body of these two subrequests get concatenated together according to their running order, to form the final response body of their parent request (for <code>/main</code>):
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/main'<br/>
foo<br/>
bar<br/>
</code><p>It should be noted that the communication of <code>location</code> blocks via subrequests is limited within the same <code>server</code> block (i.e., the same virtual server configuration), so when the Nginx core processes a subrequest, it just calls a few C functions behind the scene, without doing any kind of network or UNIX domain socket communication. For this reason, subrequests are extremely efficient.
</p>
    <h3 class="con-title" id="nginx-variables-independent-variable-containers-in-subrequests">Independent Variable Containers in Subrequests <a class="anchor" href="#nginx-variables-independent-variable-containers-in-subrequests">&#61532;</a></h3>
<p>Back to our earlier discussion for the lifetime of Nginx variable containers, now we can still state that the lifetime is bound to the current request, and every request does have its own copy of all the variable containers. It is just that the "request" here can be either a main request, or a subrequest. Variables with the same name between a parent request and a subrequest will generally not interfere with each other. Let's do a small experiment to confirm this:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;main;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/foo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/bar;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main:&nbsp;$var&quot;;<br/>
}<br/>
<br/>
location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;foo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo:&nbsp;$var&quot;;<br/>
}<br/>
<br/>
location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;bar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;bar:&nbsp;$var&quot;;<br/>
}<br/>
</code><p>In this sample, we assign different values to the variable <code>$var</code> in three <code>location</code> blocks, <code>/main</code>, <code>/foo</code>, and <code>/bar</code>, and output the value of <code>$var</code> in all these locations. In particular, we intentionally output the value of <code>$var</code> in <code>location /main</code> <I>after</I> calling the two subrequests, so if value changes of <code>$var</code> in the subrequests can affect their parent request, we should see a new value output in location <code>/main</code>. The result of requesting <code>/main</code> is as follows:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/main'<br/>
foo:&nbsp;foo<br/>
bar:&nbsp;bar<br/>
main:&nbsp;main<br/>
</code><p>Apparently, the assignments to variable <code>$var</code> in those two subrequests do not affect the main request <code>/main</code> at all. This successfully verifies that both the main request and its subrequests do own different copies of variable containers.
</p>
    <h3 class="con-title" id="nginx-variables-shared-variable-containers-among-requests">Shared Variable Containers among Requests <a class="anchor" href="#nginx-variables-shared-variable-containers-among-requests">&#61532;</a></h3>
<p>Unfortunately, subrequests initiated by certain Nginx modules do share variable containers with their parent requests, like those initiated by the 3rd-party module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a>. Below is such an example:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;main;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;auth_request&nbsp;/sub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main:&nbsp;$var&quot;;<br/>
}<br/>
<br/>
location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;sub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub:&nbsp;$var&quot;;<br/>
}<br/>
</code><p>Here in <code>location /main</code>, we first assign the initial value <code>main</code> to variable <code>$var</code>, then fire a subrequest to <code>/sub</code> via the <code>auth_request</code> directive from the <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> module, and finally output the value of <code>$var</code>. Note that in <code>location /sub</code> we intentionally overwrite the value of <code>$var</code> to <code>sub</code>. When accessing <code>/main</code>, we get
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/main'<br/>
main:&nbsp;sub<br/>
</code><p>Obviously, the value change of <code>$var</code> in the subrequest to <code>/sub</code> does affect the main request to <code>/main</code>. Thus the variable container of <code>$var</code> is indeed shared between the main request and the subrequest created by the <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> module.
</p>
<p>For the previous example, some readers might ask: "why doesn't the response body of the subrequest appear in the final output?" The answer is simple: it is just because the <code>auth_request</code> directive discards the response body of the subrequest it manages, and only checks the response status code of the subrequest. When the status code looks good, like <code>200</code>, <code>auth_request</code> will just allow Nginx continue processing the main request; otherwise it will immediately abort the main request by returning a <code>403</code> error page, for example. In our example, the subrequest to <code>/sub</code> just return a <code>200</code> response implicitly created by the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive in <code>location /sub</code>.
</p>
<p>Even though sharing variable containers among the main request and all its subrequests could make bidirectional data exchange easier, it could also lead to unexpected subtle issues that are hard to debug in real-world configurations. Because users often forget that a variable with the same name is actually used in some deeply embedded subrequest and just use it for something else in the main request, this variable could get unexpectedly modified during processing. Such bad side effects make many 3rd-party modules like  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>,  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and  <a href="http://wiki.nginx.org/HttpSRCacheModule" target="_blank">ngx_srcache</a> choose to disable the variable sharing behavior for subrequests by default.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables06">Nginx Variables (06) <a class="anchor" href="#01-nginxvariables06">&#61532;</a></h1>
    <h2 class="con-title" id="nginx-variables-built-in-variables-in-subrequests">Built-in Variables in Subrequests <a class="anchor" href="#nginx-variables-built-in-variables-in-subrequests">&#61532;</a></h2>
<p>There are some subtleties involved in using Nginx built-in variables in the context of a subrequest. We will discuss the details in this section.
</p>
    <h3 class="con-title" id="nginx-variables-built-in-variables-sensitive-to-the-subrequest-context">Built-in Variables Sensitive to the Subrequest Context <a class="anchor" href="#nginx-variables-built-in-variables-sensitive-to-the-subrequest-context">&#61532;</a></h3>
<p>We already know that most built-in variables are not simple value containers. They behave differently than user variables by registering "get handlers" and/or "set handlers". Even when they do own a value container, they usually just use the container as a result cache for their "get handlers". The  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> variable we discussed earlier, for example, just uses its "get handler" to return the URL query string for the current request. The current request here can also be a subrequest, so when reading  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> in a subrequest, its "get handler" should naturally return the query string for the subrequest. Let's see such an example:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main&nbsp;args:&nbsp;$args&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub&nbsp;&quot;a=1&amp;b=2&quot;;<br/>
}<br/>
<br/>
location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub&nbsp;args:&nbsp;$args&quot;;<br/>
}<br/>
</code><p>Here in the <code>/main</code> interface, we first echo out the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> for the current request, and then use  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> to initiate a subrequest to <code>/sub</code>. It should be noted that here we give a second argument to the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> directive, to specify the URL query string for the subrequest being fired (the first argument is the URI for the subrequest, as we already know). Finally, we define  the <code>/sub</code> interface and print out the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> in there. Querying the <code>/main</code> interface gives
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/main?c=3'<br/>
main&nbsp;args:&nbsp;c=3<br/>
sub&nbsp;args:&nbsp;a=1&amp;b=2<br/>
</code><p>It is clear that when  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is read in the main request (to <code>/main</code>), its value is the URL query string of the main request; whereas when in the subrequest (to <code>/foo</code>), it is the query string of the subrequest, <code>a=1&b=2</code>. This behavior indeed matches our intuition.
</p>
<p>Just like  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, when the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> is used in a subrequest, its "get handler" also returns the (decoded) URI of the current subrequest:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main&nbsp;uri:&nbsp;$uri&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br/>
}<br/>
<br/>
location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub&nbsp;uri:&nbsp;$uri&quot;;<br/>
}<br/>
</code><p>Below is the result of querying <code>/main</code>:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/main'<br/>
main&nbsp;uri:&nbsp;/main<br/>
sub&nbsp;uri:&nbsp;/sub<br/>
</code><p>The output is what we would expect.
</p>
    <h3 class="con-title" id="nginx-variables-built-in-variables-for-main-requests-only">Built-in Variables for Main Requests Only <a class="anchor" href="#nginx-variables-built-in-variables-for-main-requests-only">&#61532;</a></h3>
<p>Unfortunately, not all built-in variables are sensitive to the  context of subrequests. Several built-in variables always act on the main request even when they are used in a subrequest. The built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> is such an exception.
</p>
<p>Whenever  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> is read, we always get the request method name (such as <code>GET</code> and <code>POST</code>) for the main request, no matter whether the current request is a subrequest or not. Let's test it out:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main&nbsp;method:&nbsp;$request_method&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br/>
}<br/>
<br/>
location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub&nbsp;method:&nbsp;$request_method&quot;;<br/>
}<br/>
</code><p>In this example, the <code>/main</code> and <code>/sub</code> interfaces both output the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a>. Meanwhile, we initiate a <code>GET</code> subrequest to <code>/sub</code> via the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> directive in <code>/main</code>. Now let's do a <code>POST</code> request to <code>/main</code>:
</p>
<code class="block">$&nbsp;curl&nbsp;--data&nbsp;hello&nbsp;'http://localhost:8080/main'<br/>
main&nbsp;method:&nbsp;POST<br/>
sub&nbsp;method:&nbsp;POST<br/>
</code><p>Here we use the <code>--data</code> option of the <code>curl</code> utility to specify our POST request body, also this option makes <code>curl</code> use the <code>POST</code> method for the request. The test result turns out as we predicted: the variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> is evaluated to the main request's method name, <code>POST</code>, despite its use in a <code>GET</code> subrequest.
</p>
<p>Some readers might challenge our conclusion here by pointing out that we did not rule out the possibility that the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> got cached at its first reading in the main request and what we were seeing in the subrequest was actually the cached value that was evaluated earlier in the main request. This concern is unnecessary, however, because we have also learned that the variable container required by data caching (if any) is always bound to the current request, also the subrequests initiated by the  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> module always disable variable container sharing with their parent requests. Back to the previous example, even if the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> in the main request used the value container as the data cache (actually it does not), it cannot affect the subrequest by any means.
</p>
<p>To further address the concern of these readers, let's slightly modify the previous example by putting the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> statement for  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> in <code>/main</code> <I>after</I> the  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> directive that runs the subrequest:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main&nbsp;method:&nbsp;$request_method&quot;;<br/>
}<br/>
<br/>
location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub&nbsp;method:&nbsp;$request_method&quot;;<br/>
}<br/>
</code><p>Let's test it again:
</p>
<code class="block">$&nbsp;curl&nbsp;--data&nbsp;hello&nbsp;'http://localhost:8080/main'<br/>
sub&nbsp;method:&nbsp;POST<br/>
main&nbsp;method:&nbsp;POST<br/>
</code><p>No change in the output can be observed, except that the two output lines reversed the order (since we exchange the order of those two  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> module's directives).
</p>
<p>Consequently, we cannot obtain the method name of a subrequest by reading the  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> variable. This is a common pitfall for freshmen when dealing with method names of subrequests. To overcome this limitation, we need to turn to the built-in variable  <a href="http://wiki.nginx.org/HttpEchoModule#.24echo_request_method" target="_blank">$echo_request_method</a> provided by the  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> module:
</p>
<code class="block">location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main&nbsp;method:&nbsp;$echo_request_method&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br/>
}<br/>
<br/>
location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub&nbsp;method:&nbsp;$echo_request_method&quot;;<br/>
}<br/>
</code><p>We are finally getting what we want:
</p>
<code class="block">$&nbsp;curl&nbsp;--data&nbsp;hello&nbsp;'http://localhost:8080/main'<br/>
main&nbsp;method:&nbsp;POST<br/>
sub&nbsp;method:&nbsp;GET<br/>
</code><p>Now within the subrequest, we get its own method name, <code>GET</code>, as expected, and the main request method remains <code>POST</code>.
</p>
<p>Similar to  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a>, the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a> also always returns the (non-decoded) URL for the main request. This is more understandable, however, because subrequests are essentially faked requests inside Nginx, which do not really take a non-decoded raw URL.
</p>
    <h3 class="con-title" id="nginx-variables-variable-container-sharing-and-value-caching-together">Variable Container Sharing and Value Caching Together <a class="anchor" href="#nginx-variables-variable-container-sharing-and-value-caching-together">&#61532;</a></h3>
<p>In the previous section, some of the readers were worried about the case that variable container sharing in subrequests and value caching for variable's "get handlers" were working together. If it were indeed the case, then it would be a nightmare because it would be really really hard to predict what is going on by just looking at the configuration file. In previous sections, we already learned that the subrequests initiated by the <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> module are sharing the same variable containers with their parents, so we can maliciously construct such a horrible example:
</p>
<code class="block">map&nbsp;$uri&nbsp;$tag&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
}<br/>
<br/>
server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auth_request&nbsp;/sub;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;main&nbsp;tag:&nbsp;$tag&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;sub&nbsp;tag:&nbsp;$tag&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Here we use our old friend, the  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> directive, to map the value of the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> to our user variable <code>$tag</code>. When  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> takes the value <code>/main</code>, the value <code>1</code> is assigned to <code>$tag</code>; when  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> takes the value <code>/sub</code>, the value <code>2</code> is assigned instead to <code>$tag</code>; under all the other conditions, <code>0</code> is assigned. Next, in <code>/main</code>, we first initiate a subrequest to <code>/sub</code> by using the <code>auth_request</code> directive, and then output the value of <code>$tag</code>. And within <code>/sub</code>, we directly output the value of <code>$tag</code>. Guess what we will get when we access <code>/main</code>?
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/main'<br/>
main&nbsp;tag:&nbsp;2<br/>
</code><p>Ouch! Didn't we map the value <code>/main</code> to <code>1</code>? Why the actual output for <code>/main</code> is the value, <code>2</code>, for <code>/sub</code>? What is going on here?
</p>
<p>Actually it worked like this: our <code>$tag</code> variable was first read in the subrequest to <code>/sub</code>, and the "get handler" registered by  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> computed the value <code>2</code> for <code>$tag</code> in that context (because  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> was <code>/sub</code> in the subrequest) and the value <code>2</code> got cached in the value container of <code>$tag</code> from then on. Because the parent request shared the same container as the subrequest created by <code>auth_request</code>, when the parent request read <code>$tag</code> later (after the subrequest was finished), the cached value <code>2</code> was directly returned! Such results can indeed be very surprising at first glance.
</p>
<p>From this example, we can conclude again that it can hardly be a good idea to enable variable container sharing in subrequests.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables07">Nginx Variables (07) <a class="anchor" href="#01-nginxvariables07">&#61532;</a></h1>
    <h2 class="con-title" id="nginx-variables-special-value-invalid-and-not-found">Special Value "Invalid" and "Not Found" <a class="anchor" href="#nginx-variables-special-value-invalid-and-not-found">&#61532;</a></h2>
<p>We have mentioned that the values of Nginx variables can only be of one single type, that is, the string type, but variables could also have no meaningful values at all. Variables without any meaningful values still take a special value though. There are two possible special values: "invalid" and "not found".
</p>
<p>For example, when a user variable <code>$foo</code> is created but not assigned yet, <code>$foo</code> takes the special value of "invalid". And when the current URL query string does not have the <code>XXX</code> argument at all, the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>  takes the special value of "not found".
</p>
<p>Both "invalid" and "not found" are special values, completely different from an empty string value (<code>""</code>). This is very similar to those distinct special values in some dynamic programing languages, like <code>undef</code> in Perl, <code>nil</code> in Lua, and <code>null</code> in JavaScript.
</p>
<p>We have seen earlier that an uninitialized variable is evaluated to an empty string when used in an interpolated string, its real value, however, is not an empty string at all. It is the "get handler" registered by the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive that automatically converts the "invalid" special value into an empty string. To verify this, let's return to the example we have discussed before:
</p>
<code class="block">location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo&nbsp;=&nbsp;[$foo]&quot;;<br/>
}<br/>
<br/>
location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo&nbsp;=&nbsp;[$foo]&quot;;<br/>
}<br/>
</code><p>When accessing <code>/foo</code>, the user variable <code>$foo</code> is uninitialized when used in the interpolated string for the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive. The output shows that the variable is evaluated to an empty string:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br/>
foo&nbsp;=&nbsp;[]<br/>
</code><p>From the output, the uninitialized <code>$foo</code> variable behaves just like taking an empty string value. But careful readers should have already noticed that, for the request above, there is a warning in the Nginx error log file (which is <code>logs/error.log</code> by default):
</p>
<code class="block">[warn]&nbsp;5765#0:&nbsp;*1&nbsp;using&nbsp;uninitialized&nbsp;&quot;foo&quot;&nbsp;variable,&nbsp;...<br/>
</code><p>Who on earth generates this warning? The answer is the "get handler" of <code>$foo</code>, registered by the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> directive. When <code>$foo</code> is read, Nginx first checks the value in its container but sees the "invalid" special value, then Nginx decides to continue running <code>$foo</code>'s "get handler", which first prints the warning (as shown above) and then returns an empty string value, which thereafter gets cached in <code>$foo</code>'s value container.
</p>
<p>Careful readers should have identified that this process for user variables is exactly the same as the mechanism we discussed earlier for built-in variables involving "get handlers" and result caching in value containers. Yes, it is the same mechanism in action. It is also worth noting that  only the "invalid" special value will trigger the "get handler" invocation in the Nginx core while "not found" will not.
</p>
<p>The warning message above usually indicates a typo in the variable name or misuse of uninitialized variables, not necessarily in the context of an interpolated string. Because of the existence of value caching in the variable container, this warning will not get printed multiple times in the lifetime of the current request. Also, the  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> module provides the  <a href="http://wiki.nginx.org/HttpRewriteModule#uninitialized_variable_warn" target="_blank">uninitialized_variable_warn</a> directive for disabling this warning altogether.
</p>
    <h3 class="con-title" id="nginx-variables-testing-special-values-of-nginx-variables-in-lua">Testing Special Values of Nginx Variables in Lua <a class="anchor" href="#nginx-variables-testing-special-values-of-nginx-variables-in-lua">&#61532;</a></h3>
<p>As we have just mentioned, the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> takes the special value "not found" when the URL argument <code>XXX</code> does not exist, but unfortunately, it is not easy to distinguish it from the empty string value directly in the Nginx configuration file, for example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;name:&nbsp;[$arg_name]&quot;;<br/>
}<br/>
</code><p>Here we intentionally omit the URL argument <code>name</code> in our request:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
name:&nbsp;[]<br/>
</code><p>We can see that we are still getting an empty string value, because this time it is the Nginx "script engine" that automatically converts the "not found" special value to an empty string when performing variable interpolation.
</p>
<p>Then how can we test the special value "not found"? Or in other words, how can we distinguish it from normal empty string values? Obviously, in the following example, the URL argument <code>name</code> does take an ordinary value, which is a true empty string:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?name='<br/>
name:&nbsp;[]<br/>
</code><p>But we cannot really differentiate this from the earlier case that does not mention the <code>name</code> argument at all.
</p>
<p>Luckily, we can easily achieve this in Lua by means of the 3rd-party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a>. Please look at the following example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.arg_name&nbsp;==&nbsp;nil&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;name:&nbsp;missing&quot;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;name:&nbsp;[&quot;,&nbsp;ngx.var.arg_name,&nbsp;&quot;]&quot;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;';<br/>
}<br/>
</code><p>This example is very close to the previous one in terms of functionality. We use the  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> directive from the  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> module to embed a small piece of our own Lua code to test against the special value of the Nginx variable <code>$arg_name</code>. When <code>$arg_name</code> takes a special value (either "not found" or "invalid"), we will get the following output when requesting <code>/foo</code>:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
name:&nbsp;missing<br/>
</code><p>This is our first time meeting the  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> module, which deserves a brief introduction. This module embeds the Lua language interpreter (or LuaJIT's Just-in-Time compiler) into the Nginx core, to allow Nginx users directly run their own Lua programs inside the server. The user can choose to insert her Lua code into different running phases of the server, to fulfill different requirements. Such Lua code are either specified directly as literal strings in the Nginx configuration file, or reside in external <code>.lua</code> source files (or Lua binary bytecode files) whose paths are specified in the Nginx configuration.
</p>
<p>Back to our example, we cannot directly write something like <code>$arg_name</code> in our Lua code. Instead, we reference Nginx variables in Lua by means of the <code>ngx.var</code> API provided by the  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> module. For example, to reference the Nginx variable <code>$VARIABLE</code> in Lua, we just write  <a href="http://wiki.nginx.org/HttpLuuaModule#ngx.var.VARIABLE" target="_blank">ngx.var.VARIABLE</a>. When the Nginx variable <code>$arg_name</code> takes the special value "not found" (or "invalid"), <code>ngx.var.arg_name</code> is evaluated to the <code>nil</code> value in the Lua world. It should also be noting that we use the Lua function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank">ngx.say</a> to print out the response body contents, which is functionally equivalent to the  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> directive we are already very familiar with.
</p>
<p>If we provide a <code>name</code> URI argument that takes an empty value in the request, the output is now very different:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?name='<br/>
name:&nbsp;[]<br/>
</code><p>In this test, the value of the Nginx variable <code>$arg_name</code> is a true empty string, neither "not found" nor "invalid". So in Lua, the expression <code>ngx.var.arg_name</code> evaluates to the Lua empty string (<code>""</code>), clearly distinguished from the Lua <code>nil</code> value in the previous test.
</p>
<p>This differentiation is important in certain application scenarios. For instance, some web services have to decide whether to use a column value to filter the data set by checking the <I>existence</I> of the corresponding URI argument. For these serives, when the <code>name</code> URI argument is absent, the whole data set are just returned; when the <code>name</code> argument takes an empty value, however, only those records that take an empty value are returned.
</p>
<p>It is worth mentioning a few limitations in the standard  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variable. Consider using the following request to test <code>/test</code> in our previous example using Lua:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?name'<br/>
name:&nbsp;missing<br/>
</code><p>Now the <code>$arg_name</code> variable still reads the "not found" special value, which is apparently counter-intuitive. Additionally, when multiple URI arguments with the same name are specified in the request,  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> just returns the first value of the argument, discarding other values silently:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?name=Tom&amp;name=Jim&amp;name=Bob'<br/>
name:&nbsp;[Tom]<br/>
</code><p>To solve these problems, we can use the Lua function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.req.get_uri_args" target="_blank">ngx.req.get_uri_args</a> provided by the  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> module instead.</p>
</article>
<article>
    <h1 class="con-title" id="01-nginxvariables08">Nginx Variables (08) <a class="anchor" href="#01-nginxvariables08">&#61532;</a></h1>
<p>In <a href="#01-NginxVariables02">(02)</a> we mentioned that another category of builtin variables  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a> are like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>. Similarly when there exist no cookie named <code>XXX</code>, its corresponding Nginx variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a> has non-value "not found".
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.cookie_user&nbsp;==&nbsp;nil&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;cookie&nbsp;user:&nbsp;missing&quot;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;cookie&nbsp;user:&nbsp;[&quot;,&nbsp;ngx.var.cookie_user,&nbsp;&quot;]&quot;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;';<br/>
}<br/>
</code><p>The <code>curl</code> utility offers the <code>--cookie name=value</code> option, which designates <code>name=value</code> as a cookie of its request (by adding the <code>Cookie</code> header). Let's test a few cases containing cookies.
</p>
<code class="block">$&nbsp;curl&nbsp;--cookie&nbsp;user=agentzh&nbsp;'http://localhost:8080/test'<br/>
cookie&nbsp;user:&nbsp;[agentzh]<br/>
<br/>
$&nbsp;curl&nbsp;--cookie&nbsp;user=&nbsp;'http://localhost:8080/test'<br/>
cookie&nbsp;user:&nbsp;[]<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
cookie&nbsp;user:&nbsp;missing<br/>
</code><p>As expected, when cookie <code>user</code> does not exist, Lua variable <code>ngx.var. cookie_user</code> is <code>nil</code>. So we have successfully distinguished the case with empty string and the case with non-value.
</p>
<p>A nice add-on with module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> is when lua references an undeclared variable of Nginx, the variable is <code>nil</code> and Nginx will not aborts it loading as before.
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;$blah&nbsp;=&nbsp;&quot;,&nbsp;ngx.var.blah)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;';<br/>
}<br/>
</code><p>User variable <code>$blah</code> is never declared in the Nginx configuration <code>nginx. conf</code>, but it is referenced as <code>ngx.var.blah</code> in Lua code. Nginx can be started still, because when Nginx loads its configuration, Lua code is only compiled but not executed, So Nginx has no idea a variable <code>$blah</code> is referenced. When lua command is executed in run time by command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>, the lua variable is evaluated as <code>nil</code>. Module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and its command  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank">ngx.say</a> will convert Lua <code>nil</code> into string <code>"nil"</code> before it is printed, so the output will be:
</p>
<code class="block">curl&nbsp;'http://localhost:8080/test'<br/>
$blah&nbsp;=&nbsp;nil<br/>
</code><p>This is indeed what we want.
</p>
<p>We should have noticed also, when command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> includes <code>$blah</code> in its parameter, it is never evaluated as "variable interpolation" does (otherwise Nginx will be complaining variable <code>$blah</code> is not declared). This is because command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> does not really support "variable interpolation" . As we have said earlier in <a href="#01-NginxVariables01">(01)</a>, Nginx command does not necessarily support "variable interpolation" and it is entirely up to the module implementation.
</p>
<p>It's actually difficult to return an "invalid" non-value. As we learnt in <a href="#01-NginxVariables07">(07)</a>, variables which are declared but not initialized by  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> has non-value "invalid". However, as soon as the variable is devalued, the "get handler" is executed and an empty string is computed and cached, so eventually empty string is returned, not the "invalid" non-value. Following lua code can prove this:
</p>
<code class="block">location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.foo&nbsp;==&nbsp;nil&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;$foo&nbsp;is&nbsp;nil&quot;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say(&quot;$foo&nbsp;=&nbsp;[&quot;,&nbsp;ngx.var.foo,&nbsp;&quot;]&quot;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;';<br/>
}<br/>
<br/>
location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;foo&nbsp;=&nbsp;[$foo]&quot;;<br/>
}<br/>
</code><p>By requesting to <code>location /foo</code> we have:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br/>
$foo&nbsp;=&nbsp;[]<br/>
</code><p>As we can tell, when Lua references uninitialized Nginx variable <code>$foo</code>, it obtains empty string.
</p>
<p>Last not the least, we should have pointed out, although Nginx variable can have only strings as valid value. The 3rd party module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> can support array like operations for Nginx variable.Here is an example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;array_split&nbsp;&quot;,&quot;&nbsp;$arg_names&nbsp;to=$array;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;array_map&nbsp;&quot;[$array_it]&quot;&nbsp;$array;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;array_join&nbsp;&quot;&nbsp;&quot;&nbsp;$array&nbsp;to=$res;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$res;<br/>
}<br/>
</code><p>Module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> provides commands <code>array_split</code>, <code>array_map</code> and <code>array_join</code>. The semantics is pretty close to the builtin functions <code>split</code>, <code>map</code> and <code>join</code> in Perl (other languages support similar functionalities too). Now let's check what happens when <code>location /test</code> is requested:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test?names=Tom,Jim,Bob'<br/>
[Tom]&nbsp;[Jim]&nbsp;[Bob]<br/>
</code><p>Clearly module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> make it easier to handle inputs with variable length, such as the URL parameter <code>name</code>, which composes of multiple comma delimited names. Still we must emphasize, module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> is a much better choice to execute this kind of complicated tasks, usually it is more flexible and maintainable.
</p>
<p>Till now the tutorial covers the Nginx variable. In the process we have been discussing many builtin and 3rd party Nginx modules, these modules help us better understand features and internals of Nginx variable by composing various mini constructs. Later on the tutorial will be covering more details of those modules.
</p>
<p>With these examples, we should understand that Nginx variable plays a key role in the Nginx mini language: variables are the ways and means Nginx communicate internally, they contain all the needed information (including the request information) and they are the cornerstone elements which bridge every other Nginx modules. Nginx variables are everywhere in the coming tutorials, understand them is absolutely necessary.
</p>
<p>In the coming tutorial "<a href="#02-nginxdirectiveexecorder01">Nginx Directive Execution Order</a>", we will be discussing in detail the Nginx execution ordering and the phases every request traverses. It' s indispensable to understand them since for the Nginx mini language, the ordering of writing can be dramatically different from the ordering of executing in the timeline. It usually confuses many Nginx users.</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder01">Nginx directive execution order (01) <a class="anchor" href="#02-nginxdirectiveexecorder01">&#61532;</a></h1>
<p>When there are multiple Nginx module commands in a  <code>location</code> directive, the execution order can be  different from what you expect. Busy Nginx users who  attempt to configure Nginx by "trial and error" may be very confused by this behavior. This series is to  uncover the mysteries and help you better understand the execution ordering behind the scenes.
</p>
<p>We start with a confused example:
</p>
<code class="block">?&nbsp;location&nbsp;/test&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br/>
?<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br/>
?&nbsp;}<br/>
</code><p>Clearly, we'd expect to output <code>32</code>, followed by <code>56</code>. Because variable <code>$a</code> has been reset after command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> "is executed". Really? the reality is:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test<br/>
56<br/>
56<br/>
</code><p>Wow, statement <code>set $a 56</code> must have had been executed before the first <code>echo $a</code> command, but why? Is it a Nginx bug?
</p>
<p>No, this is not an Nginx bug. When Nginx handles every request, the execution follows a few predefined phases.
</p>
<p>There can be altogether 11 phases when Nginx handles a request, let's start with three most common ones: <code>rewrite</code>, <code>access</code> and <code>content</code> (The other phases will be addressed later.)
</p>
<p>Usually an Nginx module and its commands register their execution in only one of those phases. For example command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> runs in phase <code>rewrite</code>, and command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> runs in phase <code>content</code>. Since phase <code>rewrite</code> occurs before phase <code>content</code> for every request processing, its commands are executed earlier as well. Therefore, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> always gets executed before command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> within one <code>location</code> directive, regardless of their statement ordering in the configuration.
</p>
<p>Back to our example:
</p>
<code class="block">set&nbsp;$a&nbsp;32;<br/>
echo&nbsp;$a;<br/>
<br/>
set&nbsp;$a&nbsp;56;<br/>
echo&nbsp;$a;<br/>
</code><p>The actual execution ordering is:
</p>
<code class="block">set&nbsp;$a&nbsp;32;<br/>
set&nbsp;$a&nbsp;56;<br/>
echo&nbsp;$a;<br/>
echo&nbsp;$a;<br/>
</code><p>It's clear now, two commands  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> are executed in phase <code>rewrite</code>, two commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> are executed afterwards in phase <code>content</code>. Commands in different phases cannot be executed  back and forth.
</p>
<p>To prove this, we can enable Nginx's "debug log".
</p>
<p>If you have not worked with Nginx "debug log" before, here is a brief introduction. The "debug log" is disabled by default because  performance is degraded when it is enabled. To enable "debug log"  you must reconfigure and recompile Nginx, and set the  <code>--with-debug</code> option for the package's <code>./configure</code> script. When building under Linux or Mac OS X from source:
</p>
<code class="block">tar&nbsp;xvf&nbsp;nginx-1.0.10.tar.gz<br/>
cd&nbsp;nginx-1.0.10/<br/>
./configure&nbsp;--with-debug<br/>
make<br/>
sudo&nbsp;make&nbsp;install<br/>
</code><p>In case the package <a href="http://openresty.org" target="_blank">ngx_openresty</a> is used. The option <code>--with-debug</code> can be used with its <code>./configure</code> script as well.
</p>
<p>After we rebuild the Nginx debug binary with <code>--with-debug</code> option, we still need to explicitly use the <code>debug</code> log level (it's the lowest level) for command  <a href="http://wiki.nginx.org/CoreModule#error_log" target="_blank">error_log</a>, in Nginx configuration:
</p>
<code class="block">error_log&nbsp;logs/error.log&nbsp;debug;<br/>
</code><p><code>debug</code>, the second parameter of command  <a href="http://wiki.nginx.org/CoreModule#error_log" target="_blank">error_log</a> is crucial. Its first parameter is error log's file path, <code>logs/error.log</code>. Certainly we can use another file path but do remember the location because we need to check its content right away.
</p>
<p>Now let's restart Nginx (Attention, it's not enough to reload Nginx. It needs to be killed and restarted because we've updated the Nginx binary). Then we can send the request again:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
56<br/>
56<br/>
</code><p>It's time to check Nginx's error log, which is becoming a lot more verbose (more than 700 lines for the request in my setup). So let's apply the <code>grep</code> command to filter what we would be interested:
</p>
<code class="block">grep&nbsp;-E&nbsp;'http&nbsp;(output&nbsp;filter|script&nbsp;(set|value))'&nbsp;logs/error.log<br/>
</code><p>It's approximately like below (for clearness, I've edited the <code>grep</code> output and remove its timestamp etc) :
</p>
<code class="block">[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;&quot;32&quot;<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;&quot;56&quot;<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;&quot;/test?&quot;<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;&quot;/test?&quot;<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;&quot;/test?&quot;<br/>
</code><p>It barely makes any senses, does it? So let me interpret. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> dumps two lines of debug info which start with <code>http script</code>, the first line tells the value which command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> has possessed, and the second line being the variable name it will be given to, so for the leading filtered log:
</p>
<code class="block">[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;&quot;32&quot;<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br/>
</code><p>These two lines are generated by this statement:
</p>
<code class="block">set&nbsp;$a&nbsp;32;<br/>
</code><p>And for the following filtered log:
</p>
<code class="block">[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;&quot;56&quot;<br/>
[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br/>
</code><p>They are generated by this statement:
</p>
<code class="block">set&nbsp;$a&nbsp;56;<br/>
</code><p>Besides, whenever Nginx outputs its response, its "output filter" will be executed, our favorite command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> is no exception. As soon as Nginx's "output filter" is executed, it generates debug log like below:
</p>
<code class="block">[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;&quot;/test?&quot;<br/>
</code><p>Of course the debug log might not have <code>"/test?"</code>, since this part corresponds to the actual request URI. By putting everything together, we can finally conclude those two commands  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> are indeed executed before the other two commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>.
</p>
<p>Considerate readers must have noticed that there are three lines of <code>http output filter</code> debug log but we were having only two output commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. In fact, only the first two debug logs are generated by the two  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> statements. The last debug log is added by module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> because it needs to flag the end of output. The flag operation itself causes Nginx's "output filter" to be executed again. Many modules including  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> has similar behavior, when they need to give output data.
</p>
<p>All right, there are no surprises with those duplicated <code>56</code> outputs. We are not given a chance to execute  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> in front of the second  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> command. Luckily, we can still achieve this with a few techniques:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$saved_a&nbsp;$a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$saved_a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br/>
}<br/>
</code><p>Now we have what we have wanted:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
32<br/>
56<br/>
</code><p>With the help of another user variable <code>$saved_a</code>, the value of <code>$a</code> is saved before it is overwritten. Be careful, the execution order of multiple  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> commands are ensured to be like their order of writing by module <ngx_rewrite>. Similarly, module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> ensures multiple  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> commands get executed in the same order of their writing.
</p>
<p>If we recall examples in <a href="#01-nginxvariables01">Nginx Variables</a>, this technique has been applied extensively. It bypasses the execution ordering difficulties introduced by Nginx phased processing.
</p>
<p>You might need to ask : "how would I know the phase a Nginx command belongs to ?" Indeed, the answer is RTFD. (Surely advanced developers can examine the C source code directly). Many module marks explicitly its applicable phase in the module's documentation, such as command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> writes below in its documentation:
</p>
<code class="block">phase:&nbsp;content<br/>
</code><p>It says the command is executed in phase <code>content</code>. If you encounters a module which misses the applicable phase in the document, you can write to its authors right away and ask for it. However, we shall be reminded, not every command has an applicable phase. Examples are command  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> introduced in <a href="#01-NginxVariables01">Nginx Variables (01)</a> and command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> introduced in <a href="#01-NginxVariables04">Nginx Variables (04)</a>. These commands, who have no explicit applicable phase, are declarative and unrelated to the conception of execution ordering. Igor Sysoev, the author of Nginx, has made the statements a few times publicly, that Nginx mini language in its configuration is "declarative" not "procedural".</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder02">Nginx directive execution order (02) <a class="anchor" href="#02-nginxdirectiveexecorder02">&#61532;</a></h1>
<p>We've just learnt, all  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> commands within <code>location</code> are executed in <code>rewrite</code> phase. In fact, almost all commands implemented by module <code>rewrite</code> are executed in <code>rewrite</code> phase under the specific context. Commad  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> introduced in <a href="#01-NginxVariables02">Nginx Variables (02)</a> is one of them. However, we shall point out that when these commands are found in <code>server</code> directive, they will be executed in an earlier phase we've not addressed: the <code>server rewrite</code> phase.
</p>
<p>Command  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a>, introduced in <a href="#01-NginxVariables02">Nginx Variables (02)</a> is also executed in <code>rewrite</code> phase. Actually, commands implemented by module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> can mix with commands implemented by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> and the execution ordering is ensured. Let's check an example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;&quot;hello%20world&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$b&nbsp;$a;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$c&nbsp;&quot;$b!&quot;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$c;<br/>
}<br/>
</code><p>By sending a request accordingly we have:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
hello&nbsp;world!<br/>
</code><p>Apparently, the  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> command and its neighboring  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> commands are all executed in the order of their writing.
</p>
<p>To further demonstrate our assertion, we check again Nginx "debug log" (in case it's unclear for you how to check "debug log", please reference steps found in <a href="#02-NginxDirectiveExecOrder01">(01)</a>).
</p>
<code class="block">grep&nbsp;-E&nbsp;'http&nbsp;script&nbsp;(value|copy|set)'&nbsp;logs/error.log<br/>
</code><p>The debug logs are filtered as:
</p>
<code class="block">[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;&quot;hello%20world&quot;<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value&nbsp;(post&nbsp;filter):&nbsp;&quot;hello&nbsp;world&quot;<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$b<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;copy:&nbsp;&quot;!&quot;<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$c<br/>
</code><p>The leading two lines:
</p>
<code class="block">[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;&quot;hello%20world&quot;<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br/>
</code><p>They correspond to the command
</p>
<code class="block">set&nbsp;$a&nbsp;&quot;hello%20world&quot;;<br/>
</code><p>The following two lines:
</p>
<code class="block">[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value&nbsp;(post&nbsp;filter):&nbsp;&quot;hello&nbsp;world&quot;<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$b<br/>
</code><p>They are generated by command
</p>
<code class="block">set_unescape_uri&nbsp;$b&nbsp;$a;<br/>
</code><p>There are minor differences in the first line, if we compare to the logs generated by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>: the <code>"(post filter)"</code> addition. In the end of the line, URL decoding has successfully executed as we wish. <code>"hello%20world"</code> is decoded as <code>"hello world"</code>.
</p>
<p>The last two lines of debug log:
</p>
<code class="block">[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;copy:&nbsp;&quot;!&quot;<br/>
[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$c<br/>
</code><p>They are generated by the last  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> command
</p>
<code class="block">set&nbsp;$c&nbsp;&quot;$b!&quot;;<br/>
</code><p>As you might have noticed, since "variable interpolation" is evaluated when variable <code>$c</code> is declared and initialized, the debug log starts with <code>http script copy</code>. In the end of the log it is the string constant <code>"!"</code> to be concatenated.
</p>
<p>With the log information, it's fairly easy to tell the command execution ordering:
</p>
<code class="block">set&nbsp;$a&nbsp;&quot;hello%20world&quot;;<br/>
set_unescape_uri&nbsp;$b&nbsp;$a;<br/>
set&nbsp;$c&nbsp;&quot;$b!&quot;;<br/>
</code><p>It is a perfect match to the statements ordering.
</p>
<p>Just like the commands implemented in module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a>, command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> implemented in 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a>, can mix with commands of module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> as well. As introduced in <a href="#01-NginxVariables07">Nginx Variables (07)</a>, command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> supports computation with given Lua code, and assigns the computed result to a Nginx variable. As command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> does, command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> declares Nginx variable before initialization if the variable does not exist.
</p>
<p>Let's check a mixed example which comprises command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> and  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$b&nbsp;56;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set_by_lua&nbsp;$c&nbsp;&quot;return&nbsp;ngx.var.a&nbsp;+&nbsp;ngx.var.b&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$equation&nbsp;&quot;$a&nbsp;+&nbsp;$b&nbsp;=&nbsp;$c&quot;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$equation;<br/>
}<br/>
</code><p>Variable <code>$a</code> and <code>$b</code> are initialized with numerical value <code>32</code> and <code>56</code> respectively, then command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> is used together with given Lua code to compute the sum of <code>$a</code> and <code>$b</code>. Variable <code>$c</code> is initialized with the computed value. Finally, variables <code>$a</code>, <code>$b</code> and <code>$c</code> are concatenated by "variable interpolation" and assigns the result to variable <code>$equation</code>, which is printed by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>.
</p>
<p>We shall pay attention to a few points in the example: Firstly Nginx variable <code>$VARIABLE</code> is referenced as  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE" target="_blank">ngx.var.VARIABLE</a> in Lua code. Secondly, since Nginx variables are strings, the value of variable <code>ngx.var.a</code> and <code>ngx.var.b</code> are actually strings <code>"32"</code> and <code>"56"</code>, however they are automatically converted to numerical values by Lua in the addition operation. Thirdly Lua code returns to Nginx variable <code>$c</code> the computed sum value by statement <code>return</code>. Finally when Lua code returns, it actually converts the numerical value back to string. (because string is the only valid value for Nginx variable)
</p>
<p>The actual output meets our expectation:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
32&nbsp;+&nbsp;56&nbsp;=&nbsp;88<br/>
</code><p>This in fact asserts that command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> can mix with commands implemented by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>, such as  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>.
</p>
<p>Many other 3rd party modules support the mix with module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> as well. The examples include module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a>, discussed in <a href="#01-NginxVariables08">Nginx Variables (08)</a> and module  <a href="http://wiki.nginx.org/HttpEncryptedSessionModule" target="_blank">ngx_encrypted_session</a>, which encrypts sessions. The latter will be studied in detail shortly.
</p>
<p>Since builtin module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> is virtually indispensable, it's a great advantage for the 3rd party module has the caliber of being mixed with. Truth is, all of those 3rd party modules have adopted a special technique, which allows the "injection" of their execution into commands of module <code>rewrite</code> (with the help of a 3rd party module <a href="https://github.com/simpl/ngx_devel_kit" target="_blank">ngx_devel_kit</a> developed by Marcus Clyne). For the rest regular 3rd party modules, which also register their execution in phase <code>rewrite</code>, their commands are executed separately from module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> in runtime. In fact, it's hardly accurate to tell the commands execution ordering in between different modules (strictly speaking they are usually executed in the order of loading, but exception does exist). For example both modules, <code>A</code> and <code>B</code> register their commands to be executed in phase <code>rewrite</code>, then it is either the case in which commands of <code>A</code> are executed followed by <code>B</code> or the other complete way around. Unless it is explicitly documented, we cannot rely on the uncertain ordering in our configurations.</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder03">Nginx directive execution order  (03) <a class="anchor" href="#02-nginxdirectiveexecorder03">&#61532;</a></h1>
<p>As discussed earlier, unless special techniques are utilized as module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> does, a module can not mix its commands with  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>, and expects the correct execution order. Even if the commands are registered in the <code>rewrite</code> phase as well. We can demonstrate with some examples.
</p>
<p>3rd party module  <a href="http://wiki.nginx.org/HttpHeadersMoreModule" target="_blank">ngx_headers_more</a> provides a few commands, which deal with the current request header and response header. One of them is  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_header" target="_blank">more_set_input_header</a>. The command can modify a given request header in <code>rewrite</code> phase (or add the specific header if it's not available in current request). As described in its documentation, the command always executes in the end of <code>rewrite</code> phase:
</p>
<code class="block">phase:&nbsp;rewrite&nbsp;tail<br/>
</code><p>Being terse though, <code>rewrite tail</code> means the end of phase <code>rewrite</code>.
</p>
<p>Since it executes in the end of phase <code>rewrite</code>, the implication is its execution is always after the commands implemented in module <code>ngx_rewrite</code>. Even if it is written at the very beginning:
</p>
<code class="block">?&nbsp;location&nbsp;/test&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$value&nbsp;dog;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;more_set_input_headers&nbsp;&quot;X-Species:&nbsp;$value&quot;;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$value&nbsp;cat;<br/>
?<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;X-Species:&nbsp;$http_x_species&quot;;<br/>
?&nbsp;}<br/>
</code><p>As briefly introduced in <a href="#01-NginxVariables02">Nginx Variables (02)</a>, Builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank">$http_XXX</a> has the header <code>XXX</code> for the current request. We must be careful though, variable <$http_XXX> matches to the normalized request header, i.e. it lower cases capital letters and turns minus <code>-</code> into underscore <code>_</code> for the request header names. Therefore variable <code>$http_x_species</code> can successfully catches the request header <code>X-Species</code>, which is declared by command  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_header" target="_blank">more_set_input_header</a>.
</p>
<p>Because of the statement ordering, we might have mistakenly concluded header <code>X-Species</code> has the value <code>dog</code> when <code>/test</code> is requested. But the actual result is different:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
X-Species:&nbsp;cat<br/>
</code><p>Clearly, statement <code>set $value cat</code> is executed earlier than  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank">more_set_input_headers</a>, although it is written afterwards.
</p>
<p>This example tells us that commands of different modules are executed independently from each other, even if they are all registered in the same processing phase. (unless it is implemented as module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a>, whose commands are specifically tuned with module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>). In other words, every processing phase is further divided into sub-phases by Nginx modules.
</p>
<p>Similar to  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank">more_set_input_headers</a>, command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> provided by 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> execute in the end of <code>rewrite</code> phase as well. We can verify this:
</p>
<code class="block">?&nbsp;location&nbsp;/test&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;1;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite_by_lua&nbsp;&quot;ngx.var.a&nbsp;=&nbsp;ngx.var.a&nbsp;+&nbsp;1&quot;;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br/>
?<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br/>
?&nbsp;}<br/>
</code><p>By using Lua code specified by command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> Nginx variable <code>$a</code> is incremented by 1.We might have expected the result be <code>56</code> if we are looking at the writing sequence.The actual result is <code>57</code> because command <ngx_lua/rewrite_by_lua> is always executed after all the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> statements.
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
57<br/>
</code><p>Admittedly command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> has different behavior than command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a>, which is discussed in <a href="#02-NginxDirectiveExecOrder02">(02)</a>.
</p>
<p>Out of sheer curiosity, we shall ask immediately that what would be execution ordering in between  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank">more_set_input_headers</a> and  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a>, since they both ride on <code>rewrite</code> tail? The answer is : undefined. We must avoid a configuration which relies on their execution orders.
</p>
<p>Nginx phase <code>rewrite</code> is a rather early processing phase. Usually commands registered in this phase execute various rewrite tasks on the request (for example rewrite the URL or the URL parameters), the commands might also declare and initialize Nginx variables which are needed in the subsequent handling. Certainly, one cannot forbid others to complicate themselves by checking the request body, or visit a database etc. After all, command like  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> offers the caliber to stuff in any potentially mind twisted Lua code.
</p>
<p>After phase <code>rewrite</code>, Nginx has another phase called <code>access</code>. The commands provided by 3rd party module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a>, which is discussed in <a href="#01-NginxVariables05">Nginx Variables (05)</a>, execute in phase <code>access</code>. Commands registered in <code>access</code> phase mostly carry out ACL functionalities, such as guarding user clearance, checking user origins, examining source IP validity etc.
</p>
<p>For example command  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> and  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> provided by builtin module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> can control which IP addresses have the privileges to visit, or which IP addresses are rejected:
</p>
<code class="block">location&nbsp;/hello&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;127.0.0.1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;hello&nbsp;world&quot;;<br/>
}<br/>
</code><p>Location <code>/hello</code> allows visit from localhost (IP address <code>127.0.0.1</code>) and reject requests from all other IP addresses (returns http error <code>403</code>) The rules defined by  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> commands are asserted in the writing sequence. Once one rule is matched, the assertion stops and all the rest  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> or  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> commands are ignored. If no rule is matched, handling continues in the following statements. If the matched rule is  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a>, handing is aborted and error <code>403</code> is returned immediately. In our example, request issued from localhost matches to the rule <code>allow 127.0.0.1</code> and handing continues to the other statements, however request issued from every other IP addresses will match rule <code>deny all</code> handling is therefore aborted and error <code>403</code> is returned.
</p>
<p>We can give it a test, by sending request from localhost:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/hello'<br/>
hello&nbsp;world<br/>
</code><p>If request is sent from another machine (suppose Nginx runs on IP <code>192.168.1.101</code> ) we have:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://192.168.1.101:8080/hello'<br/>
&lt;html&gt;<br/>
&lt;head&gt;&lt;title&gt;403&nbsp;Forbidden&lt;/title&gt;&lt;/head&gt;<br/>
&lt;body&nbsp;bgcolor=&quot;white&quot;&gt;<br/>
&lt;center&gt;&lt;h1&gt;403&nbsp;Forbidden&lt;/h1&gt;&lt;/center&gt;<br/>
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br/>
&lt;/body&gt;<br/>
&lt;/html&gt;<br/>
</code><p>By the way, module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> supports the "CIDR notation" to designate a sub-network. For example <code>169.200.179.4/24</code> represents the sub-network which has the routing prefix <code>169.200.179.0</code> (or subnet mask <code>255.255. 255.0</code>)
</p>
<p>Because commands of module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> execute in <code>access</code> phase, and phase <code>access</code> is behind <code>rewrite</code> phase. So for those commands we have been discussing, regardless of the writing order they always execute in <code>rewrite</code> phase, which is earlier than  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> or  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a>. Keep this in mind, we shall try our best to keep the writing and execution order consistent.</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder04">Nginx directive execution order (04) <a class="anchor" href="#02-nginxdirectiveexecorder04">&#61532;</a></h1>
<p>Module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> implements another command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>. The command allows lua code to be executed in the end of <code>access</code> phase, which means it always executes after  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> and  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> even they belong to the same phase. In many cases, we examine the request' s source IP address with  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>, and use command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> to execute more complicated verifications with Lua. For example by querying a database or other backend services, the current user's identity and privileges are examined.
</p>
<p>We can check a simple example, which uses command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> to implement the IP filtering functionality of module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>
</p>
<code class="block">location&nbsp;/hello&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.remote_addr&nbsp;==&nbsp;&quot;127.0.0.1&quot;&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.exit(403)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;';<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;hello&nbsp;world&quot;;<br/>
}<br/>
</code><p>Nginx's builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> is referenced in Lua to get the client's IP address. Then Lua statement <code>if</code> is used to determine if the address equals <code>127.0.0.1</code>. Lua returns if it equals, Nginx thus continues the subsequent handling (including the <code>content</code> phase where command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> applies to). If it is not the localhost address, current handling is aborted by using  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> module's Lua function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.exit" target="_blank">ngx.exit</a> Client gets a http error <code>403</code>.
</p>
<p>The example is equivalent to the other example using  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> module in terms of functionality, which was discussed in <a href="#02-NginxDirectiveExecOrder03">(03)</a>:
</p>
<code class="block">location&nbsp;/hello&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;127.0.0.1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;hello&nbsp;world&quot;;<br/>
}<br/>
</code><p>However we shall point out, performance wise the two still have differences. Module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> performs better because it is specifically implemented as a Nginx module in C.
</p>
<p>We can measure the performance differences of the two. After all, performance is what we are after by using Nginx. On the other hand, it's absolutely necessary to be equipped with measuring techniques, because only actual data distinguishes amateurs and professionals. In fact, both  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> perform pretty good for IP filtering. To minimize measuring errors we could measure directly the elapsed time of <code>access</code> phase. Traditionally, this means hacking Nginx source code with timing code and statistical code, or recompile Nginx binary so that it can be monitored by specific profiling tools like <code>GNU gprof</code>.
</p>
<p>We are lucky, because current releases of Solaris, Mac OSX or FreeBSD offer a system utility <code>dtrace</code>, which allows micro monitoring of user process in terms of performance (and functionality as well). The tool spares us from hacking source code or recompilation with profiling. Let's demonstrate the measuring scenario on the MacBook Air because <code>dtrace</code> is available since Mac OS X 10.5
</p>
<p>First, open the Terminal application of Mac OSX, change to your preferable path and create a file named as <code>nginx-access-time.d</code>, edit the file with following content:
</p>
<code class="block">#!/usr/bin/env&nbsp;dtrace&nbsp;-s<br/>
<br/>
pid$1::ngx_http_handler:entry<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;=&nbsp;0;<br/>
}<br/>
<br/>
pid$1::ngx_http_core_access_phase:entry<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;=&nbsp;timestamp;<br/>
}<br/>
<br/>
pid$1::ngx_http_core_access_phase:return<br/>
/begin&nbsp;&gt;&nbsp;0/<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;+=&nbsp;timestamp&nbsp;-&nbsp;begin;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;=&nbsp;0;<br/>
}<br/>
<br/>
pid$1::ngx_http_finalize_request:return<br/>
/elapsed&nbsp;&gt;&nbsp;0/<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@elapsed&nbsp;=&nbsp;avg(elapsed);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;=&nbsp;0;<br/>
}<br/>
</code><p>Save the file and make it executable.
</p>
<code class="block">$&nbsp;chmod&nbsp;+x&nbsp;./nginx-access-time.d<br/>
</code><p>The <code>.d</code> file actually contains code written in <code>D</code> language offered by utility <code>dtrace</code> (attention, the <code>D</code> language is not the other <code>D</code> language, which is advocated by Walter Bright for a better C++). So far we cannot really explain in detail the code because it requires a thorough understanding of Nginx internals. Anyway we shall be clear of the code's purpose: measure requests being handled by specific Nginx worker process and calculate the average time elapsed in <code>access</code> phase.
</p>
<p>Now we can get the <code>D</code> script running. The script takes a command line parameter, which is the process id (pid) of Nginx worker. Since Nginx supports multiple worker processes and the requests can be randomly handled by anyone of them, we'd like to configure Nginx in its configuration <code>nginx.conf</code> so that only one worker is requested.
</p>
<code class="block">worker_processes&nbsp;1;<br/>
</code><p>After Nginx binary is restarted, the worker process id can be obtained by command <code>ps</code>.
</p>
<code class="block">$&nbsp;ps&nbsp;ax|grep&nbsp;nginx|grep&nbsp;worker|grep&nbsp;-v&nbsp;grep<br/>
</code><p>Typically we have:
</p>
<code class="block">10975&nbsp;&nbsp;&nbsp;??&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:34.28&nbsp;nginx:&nbsp;worker&nbsp;process<br/>
</code><p><code>10975</code> is my Nginx worker pid. In case you have multiple lines, you must have started multiple Nginx server instances or the current Nginx server has started multiple worker processes.
</p>
<p>Then as root, script <code>nginx-access-time.d</code> is executed with the worker pid
</p>
<code class="block">$&nbsp;sudo&nbsp;./nginx-access-time.d&nbsp;10975<br/>
</code><p>We shall have one output message if everything goes OK.
</p>
<code class="block">dtrace:&nbsp;script&nbsp;'./nginx-access-time.d'&nbsp;matched&nbsp;4&nbsp;probes<br/>
</code><p>The message says our <code>D</code> script has successfully deployed 4 probes on the target process. Then the script is ready to trace process <code>10975</code> constantly.
</p>
<p>Let's open another Terminal, and send multiple requests with <code>curl</code> to our monitored process
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/hello'<br/>
hello&nbsp;world<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/hello'<br/>
hello&nbsp;world<br/>
</code><p>Back to our Terminal where <code>D</code> script is running, press keys <code>Ctrl-C</code> to interrupt it. When the script bails out it prints on console the statistical result. For example my console has following result:
</p>
<code class="block">$&nbsp;sudo&nbsp;./nginx-access-time.d&nbsp;10975<br/>
dtrace:&nbsp;script&nbsp;'./nginx-access-time.d'&nbsp;matched&nbsp;4&nbsp;probes<br/>
^C<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19219<br/>
</code><p>The final <code>19219</code> is the average time elapsed in <code>access</code> phase in nano seconds (1 second = 1000x1000x1000 nano seconds)
</p>
<p>Done with the steps. We can run the <code>nginx-access-time.d</code> script to calculate average elapsed time in phase <code>access</code> for three different Nginx setups respectively. They are IP filtering with module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>, IP filtering with command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>, and finally no filtering for <code>access</code> phase. The last result helps eliminate the side effect caused by probes or other "systematic errors". Besides, we can use traffic loader tools such as <code>ab</code> to sends half a million requests to minimize "random errors", as below:
</p>
<code class="block">$&nbsp;ab&nbsp;-k&nbsp;-c1&nbsp;-n100000&nbsp;'http://127.0.0.1:8080/hello'<br/>
</code><p>Therefore the statistical result of <code>D</code> script is as close as possible to the "actual" time.
</p>
<p>In the Mac OSX, a typical run has following results:
</p>
<code class="block">ngx_access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18146<br/>
access_by_lua&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35011<br/>
no&nbsp;filtering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15887<br/>
</code><p>We minus the last value from the former two:
</p>
<code class="block">ngx_access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2259<br/>
access_by_lua&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19124<br/>
</code><p>Well, module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> out performs command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> by a magnitude, as we might have expected. Still the absolute difference is tiny. For the <code>Intel Core2Due 1.86 GHz</code> CPU of mine, there is only a few micro seconds.
</p>
<p>In fact the  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> example can be further optimized using builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24binary_remote_addr" target="_blank">$binary_remote_addr</a>. This variable has the IP address in binary form whereas variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> has the address in a longer string format. Shorter address can be compared quicker when Lua executes its string operations.
</p>
<p>Be careful, if "debug log" is enabled as introduced in <a href="#02-NginxDirectiveExecOrder01">(01)</a> the computed elapsed time will increase dramatically, because "debug log" has a huge overhead.</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder05">Nginx directive execution order (05) <a class="anchor" href="#02-nginxdirectiveexecorder05">&#61532;</a></h1>
<p><code>content</code> is by all means the most significant phase in Nginx's request handling, because commands running in the phase have the responsibility to generate "content" and output HTTP response. Because of its importance, Nginx has a rich set of commands running in it. The commands include  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a>,  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a>,  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>, which were discussed in <a href="#01-NginxVariables02">Nginx Variables (02)</a>, <a href="#01-NginxVariables03">Nginx Variables (03)</a>, <a href="#01-NginxVariables05">Nginx Variables (05)</a> and <a href="#01-NginxVariables07">Nginx Variables (07)</a> respectively.
</p>
<p><code>content</code> is a phase which runs later than <code>rewrite</code> and <code>access</code>. Therefore its commands always execute in the end when they are used together with commands of <code>rewrite</code> and <code>access</code>.
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;rewrite&nbsp;phase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$age&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite_by_lua&nbsp;&quot;ngx.var.age&nbsp;=&nbsp;ngx.var.age&nbsp;+&nbsp;1&quot;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;access&nbsp;phase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;10.32.168.49;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;&quot;ngx.var.age&nbsp;=&nbsp;ngx.var.age&nbsp;*&nbsp;3&quot;;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;content&nbsp;phase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;age&nbsp;=&nbsp;$age&quot;;<br/>
}<br/>
</code><p>This is a perfect example, in which commands are executed in an exact sequence as they are written. The testing result matches to our expectations too.
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
age&nbsp;=&nbsp;6<br/>
</code><p>In fact, the commands' writing order can be completely shuffled and it won't have any impact to their execution sequence. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>, which is implemented by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>, executes in <code>rewrite</code> phase. Command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> from module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> executes in the end of <code>rewrite</code> phase. Command  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> from module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> executes in <code>access</code> phase. Command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> from module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> executes in the end of <code>access</code> phase. Finally, our favorite command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>, implemented by module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>, executes in <code>content</code> phase.
</p>
<p>The example also demonstrates the collaborating in between commands running on each different Nginx phase. In the process, Nginx variable is the data carrier interconnecting commands and modules. The execution order of these commands is largely decided by the phase each applies to.
</p>
<p>As matter of fact, multiple commands from different modules could coexist in phase <code>rewrite</code> and <code>access</code>. As the example shows, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> and command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> both belong to phase <code>rewrite</code>. Command  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> and command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> both belong to phase <code>access</code>. However it is not the same story for phase <code>content</code>.
</p>
<p>Most modules, when they implement commands for phase <code>content</code>, they are actually inserting "content handler" for the current <code>location</code> directive, however there can be one and only one "content handler" for a <code>location</code>. So only one module could beat the rest when multiple modules are contending the role. Consider following problematic example:
</p>
<code class="block">?&nbsp;location&nbsp;/test&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;hello;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say(&quot;world&quot;)';<br/>
?&nbsp;}<br/>
</code><p>Command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> from module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> from module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> both execute in phase <code>content</code>. But only one of them could successfully become "content handler":
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
world<br/>
</code><p>Our test indicates, that the winner is  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> although it is written afterwards, and command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> never really has a chance to run. We cannot be assured which module wins in the circumstance. For example, module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> wins and the output becomes <code>hello</code> if we swap the  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> statements. So we shall avoid to use multiple commands for phase <code>content</code>, if the commands are implemented by different modules.
</p>
<p>The example can be modified by replacing command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> and we will get what we need:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;hello;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;world;<br/>
}<br/>
</code><p>Again test proves:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
hello<br/>
world<br/>
</code><p>We can use multiple  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> commands, there is no problem with this because they all belong to module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>. Module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> regulates the execution ordering of them. Be careful though, not every module supports the commands being executed multiple times within one <code>location</code>. Command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> for an instance, can be used only once, so following example is incorrect:
</p>
<code class="block">?&nbsp;location&nbsp;/test&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say(&quot;hello&quot;)';<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say(&quot;world&quot;)';<br/>
?&nbsp;}<br/>
</code><p>Nginx dumps error for the configuration:
</p>
<code class="block">[emerg]&nbsp;&quot;content_by_lua&quot;&nbsp;directive&nbsp;is&nbsp;duplicate&nbsp;...<br/>
</code><p>The correct way of doing it is:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say(&quot;hello&quot;)&nbsp;ngx.say(&quot;world&quot;)';<br/>
}<br/>
</code><p>Instead of using twice the  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> command in <code>location</code>, the approach is to call function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank">ngx.say</a> twice in the Lua code, which is executed by command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>
</p>
<p>Similarly, command  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> from module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> cannot coexist with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> within one <code>location</code> because they both execute in <code>content</code> phase. Many Nginx newbies make following mistake:
</p>
<code class="block">?&nbsp;location&nbsp;/test&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;before...&quot;;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://127.0.0.1:8080/foo;<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;after...&quot;;<br/>
?&nbsp;}<br/>
?<br/>
?&nbsp;location&nbsp;/foo&nbsp;{<br/>
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;contents&nbsp;to&nbsp;be&nbsp;proxied&quot;;<br/>
?&nbsp;}<br/>
</code><p>The example tries to output strings <code>"before..."</code> and <code>"after..."</code> with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> before and after module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> returns its content. However only one module could execute in <code>content</code>. The test indicates module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> wins and command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> from module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> never runs
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
contents&nbsp;to&nbsp;be&nbsp;proxied<br/>
</code><p>To implement what the example had wanted to, we shall use two other commands provided by module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank">echo_before_body</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank">echo_after_body</a>:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_before_body&nbsp;&quot;before...&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://127.0.0.1:8080/foo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo_after_body&nbsp;&quot;after...&quot;;<br/>
}<br/>
<br/>
location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;contents&nbsp;to&nbsp;be&nbsp;proxied&quot;;<br/>
}<br/>
</code><p>Test tells we make it:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/test'<br/>
before...<br/>
contents&nbsp;to&nbsp;be&nbsp;proxied<br/>
after...<br/>
</code><p>The reason commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank">echo_before_body</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank">echo_after_body</a> could coexist with other modules in <code>content</code> phase, is they are not "content handler" but "output filter" of Nginx. Back in <a href="#02-NginxDirectiveExecOrder01">(01)</a> when we examine the "debug log" generated by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> , we've learnt Nginx calls its "output filter" whenever Nginx outputs data. So that module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> takes the advantage of it to modify content generated by module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> (by adding surrounding content). We shall point out though, "output filter" is not one of those 11 phases mentioned in <a href="#02-NginxDirectiveExecOrder01">(01)</a> (many phases could trigger "output filter" when they output data). Still it's perfectly all right to document commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank">echo_before_body</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank">echo_after_body</a> as following:
</p>
<code class="block">phase:&nbsp;output&nbsp;filter<br/>
</code><p>It means the command executes in "output filter".</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder06">Nginx directive execution order (06) <a class="anchor" href="#02-nginxdirectiveexecorder06">&#61532;</a></h1>
<p>We've learnt in <a href="#02-NginxDirectiveExecOrder05">(05)</a> that when a command executes in <code>content</code> phase for a specific <code>location</code>, it usually means its Nginx module registers a "content handler" for the <code>location</code>. However, what happens if no module registers its command as "content handler" for phase <code>content</code> ? Who will be taking the glory of generate content and output responses ? The answer is the static resource module, which maps the request URI to the file system. Static resource module only comes into play when there is none "content handler", otherwise it hands off the duty to "content handler".
</p>
<p>Typically Nginx has three static resource modules for the <code>content</code> phase (unless one or more of those modules are disabled explicitly, or some other conflicting modules are enabled when Nginx is built) The three modules, in the order of their execution order, are  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> module,  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> module and <code>ngx_static</code> module. Let's discuss them one by one.
</p>
<p>Module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> and  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> only apply to those request URI, which ends with <code>/</code>. For the other request URI which does not end with <code>/</code>, both modules ignore them and let the following <code>content</code> phase module handle. Module <code>ngx_static</code> however, has an exact opposite strategy. It ignores the request URI which ends with <code>/</code> and handles the rest.
</p>
<p>Module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> mainly looks for a specific home page file, such as <code>index.html</code> or <code>index.htm</code> in the file system. For example:
</p>
<code class="block">location&nbsp;/&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.htm&nbsp;index.html;<br/>
}<br/>
</code><p>When address <code>/</code> is requested, Nginx looks for file <code>index.htm</code> and <code>index.html</code> (in this order) in a path in the file system. The path is specified by command  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a>. If file <code>index.htm</code> exists, Nginx jumps internally to location <code>index.htm</code>; if it does not exist and file <code>index.html</code> exists, Nginx jumps internally to location <code>index.html</code>. If file <code>index.html</code> does not exist either, and handling is transferred to the other module which executes it commands in phase <code>content</code>.
</p>
<p>We have learnt in <a href="#01-NginxVariables02">Nginx Variables (02)</a>, commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> and  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> can trigger "internal redirects" as well. The jump modifies the request URI, and looks for the corresponding <code>location</code> directive for subsequent handling. In the process, phases <code>rewrite</code>, <code>access</code> and <code>content</code> are reiterated for the <code>location</code>. The "internal redirect" is different from the "external redirect" defined by HTTP response code 302 and 301, client browser won't update its URI addresses. Therefore as soon as internal jump occurs when module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> finds the files specified by command  <a href="http://wiki.nginx.org/HttpIndexModule#index" target="_blank">index</a>, the net effect is like client would have been requesting the file's URI at the very beginning.
</p>
<p>We can check following example to witness the "internal redirect" triggered by module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a>, when it finds the needed file.
</p>
<code class="block">location&nbsp;/&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.html;<br/>
}<br/>
<br/>
location&nbsp;/index.html&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;a&nbsp;=&nbsp;$a&quot;;<br/>
}<br/>
</code><p>We need to create an empty file <code>index.html</code> under the path <code>/var/www/</code>, and make sure the file is readable for the Nginx worker process. Then we could send request to <code>/</code>:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/'<br/>
a&nbsp;=&nbsp;32<br/>
</code><p>What happened ? Why the output is not the content of file <code>index.html</code> (which shall be empty) ? Firstly Nginx uses directive <code>location /</code> to handle original <code>GET /</code> request, then module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> executes in <code>content</code> phase, and it finds file <code>index.html</code> under path <code>/var/www/</code>. At this moment, it triggers an "internal redirect" to location <code>/index.html</code>.
</p>
<p>So far so good. But here comes the surprises ! When Nginx looks for <code>location</code> directive which matches to <code>/index.html</code>, <code>location /index.html</code> has a higher priority than <code>location /</code>. This is because Nginx uses "longest matched substring" semantics to match <code>location</code> directives to request URI's prefix. When <location /index.html> directive is chosen, phases <code>rewrite</code>, <code>access</code> and <code>content</code> are reiterated, and eventually it outputs <code>a = 32</code>.
</p>
<p>What if we remove file <code>/var/www/index.html</code> in the example, and request to <code>/</code> again ? The answer is error <code>403 Forbidden</code>. Why? When module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> cannot find the file specified by command  <a href="http://wiki.nginx.org/HttpIndexModule#index" target="_blank">index</a> (<code>index.html</code> in here), it transfers the handling to the following module which executes in <code>content</code>. But none of those following modules can fulfill the request, Nginx bails out and dumps us error. Meanwhile it logs the error in Nginx error log:
</p>
<code class="block">[error]&nbsp;28789#0:&nbsp;*1&nbsp;directory&nbsp;index&nbsp;of&nbsp;&quot;/var/www/&quot;&nbsp;is&nbsp;forbidden<br/>
</code><p>The meaning of <code>directory index</code> is to generate "indexes". Usually this implies to generate a web page, which lists every file and sub directories under path <code>/var/www/</code>. If we use module  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> right after  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a>, it can generate such a page just like what we need. Now let's modify the example a little bit:
</p>
<code class="block">location&nbsp;/&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.html;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;autoindex&nbsp;on;<br/>
}<br/>
</code><p>When <code>/</code> is requested again meanwhile file <code>/var/www/index.html</code> is kept missing. A nice html page is generated:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/'<br/>
&lt;html&gt;<br/>
&lt;head&gt;&lt;title&gt;Index&nbsp;of&nbsp;/&lt;/title&gt;&lt;/head&gt;<br/>
&lt;body&nbsp;bgcolor=&quot;white&quot;&gt;<br/>
&lt;h1&gt;Index&nbsp;of&nbsp;/&lt;/h1&gt;&lt;hr&gt;&lt;pre&gt;&lt;a&nbsp;href=&quot;../&quot;&gt;../&lt;/a&gt;<br/>
&lt;a&nbsp;href=&quot;cgi-bin/&quot;&gt;cgi-bin/&lt;/a&gt;&nbsp;&nbsp;08-Mar-2010&nbsp;19:36&nbsp;&nbsp;&nbsp;-<br/>
&lt;a&nbsp;href=&quot;error/&quot;&gt;error/&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08-Mar-2010&nbsp;19:36&nbsp;&nbsp;&nbsp;-<br/>
&lt;a&nbsp;href=&quot;htdocs/&quot;&gt;htdocs/&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;05-Apr-2010&nbsp;03:55&nbsp;&nbsp;&nbsp;-<br/>
&lt;a&nbsp;href=&quot;icons/&quot;&gt;icons/&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08-Mar-2010&nbsp;19:36&nbsp;&nbsp;&nbsp;-<br/>
&lt;/pre&gt;&lt;hr&gt;&lt;/body&gt;<br/>
&lt;/html&gt;<br/>
</code><p>The page shows there are a few subdirectories under my <code>/var/www/</code>. They are <code>cgi-bin/</code>, <code>error/</code>, <code>htdocs/</code> and <code>icons/</code>. The output might be different if you have tried by yourself.
</p>
<p>Again, if file <code>/var/www/index.hmtl</code> does exist, module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> will trigger "internal redirect", and module  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> will not have a chance to execute, you may test it yourself too.
</p>
<p>The "goal keeper" module executed in phase <code>content</code> is <code>ngx_static</code>. which is also used intensively. The module serves the static files, including the static resources of a web site, such as static <code>.html</code> files, static <code>.css</code> files, static <code>.js</code> files and static image files etc. Although <code>ngx_index</code> could trigger an "internal redirect" to the specified home page, but the actual output task (takes the file content as response, and marks the corresponding response headers) is carried out by module <code>ngx_static</code>.</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder07">Nginx directive execution order (07) <a class="anchor" href="#02-nginxdirectiveexecorder07">&#61532;</a></h1>
<p>Let's check an example in which module <code>ngx_static</code> serves disk files, with following configuration snippet:
</p>
<code class="block">location&nbsp;/&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br/>
}<br/>
</code><p>Meanwhile two files are created under <code>/var/www/</code>. One file is named <code>index.html</code> and its content contains one line of text <code>this is my home</code>. Another file is named <code>hello.html</code> and its content contains one line of text <code>hello world</code>. Again be aware of the files' privileges and make sure they are readable by Nginx worker process.
</p>
<p>Now we send requests to the files' corresponding URI:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/index.html'<br/>
this&nbsp;is&nbsp;my&nbsp;home<br/>
<br/>
$&nbsp;curl&nbsp;'http://localhost:8080/hello.html'<br/>
hello&nbsp;world<br/>
</code><p>As we can see, the created file contents are sent as outputs.
</p>
<p>We can examine what is happening here: <code>location /</code> does not have any command to execute in phase <code>content</code>, therefore no module has registered a "content handler" in the <code>location</code>. The handling thus falls to the three static resource modules which are the last resorts of phase <code>content</code>. The former two modules  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> and  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> notices that the request URI does not end with <code>/</code> so they hand off immediately to module <code>ngx_static</code>, which runs in the end. According to the "document root" specified by command  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a>, module <code>ngx_static</code> maps the request URIs <code>/index.html</code> and <code>/hello.html</code> to disk files <code>/var/www/index.html</code> and <code>/var/www/hello.html</code> respectively. As both files can be found, their content are outputted as response, meanwhile response header <code>Content-Type</code>, <code>Content-Length</code> and <code>Last-Modified</code> are accordingly indicated.
</p>
<p>To verify module <code>ngx_static</code> has executed, we could enable the "debug log" introduced in <a href="#02-NginxDirectiveExecOrder01">(01)</a>. Again we send request to <code>/index.html</code> and Nginx error log will contain following debug information:
</p>
<code class="block">[debug]&nbsp;3033#0:&nbsp;*1&nbsp;http&nbsp;static&nbsp;fd:&nbsp;8<br/>
</code><p>This line is generated by module <code>ngx_static</code>. Its meaning is " outputting static resource whose file handle is <code>8</code>". Of course the numerical file handle changes every time, and the line is only a typical output in my setup. To be reminded, builtin module  <a href="http://wiki.nginx.org/HttpGzipStaticModule" target="_blank">ngx_gzip_static</a> could generate the same debug info as well, by default it is not enabled though, which will be discussed later.
</p>
<p>Command  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a> only declares a "document root", it does not enables the <code>ngx_static</code> module. The module is as matter of fact, always enabled already, but it might not have the chance to execute. This is entirely up to the other modules, which execute earlier in <code>content</code> phase. Module <code>ngx_static</code> execute only when all of them have "gave up". To prove this, check following blank <code>location</code> definition:
</p>
<code class="block">location&nbsp;/&nbsp;{<br/>
}<br/>
</code><p>Because there is no  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a> command, Nginx computes a default "document root" when the location is requested. The default shall be the <code>html/</code> subdirectory under "configure prefix". For example suppose our "configure prefix" is <code>/foo/bar/</code>, the default "document root" is <code>/foo/bar/html/</code>.
</p>
<p>So who decides "configure prefix" ? Actually it the Nginx root directory when it is installed (or the value of <code>--prefix</code> option of script <code>./configure</code> when Nginx is built). If Nginx is installed into <code>/usr/local/nginx/</code>, "configure prefix" is <code>/usr/local/nginx/</code> and default "document root" is therefore <code>/usr/local/nginx/html/</code>. Certainly a command line option <code>--prefix</code> can be given when Nginx is started, to change the "configure prefix" (so that we can easily test multiple setups). Suppose Nginx is started as following:
</p>
<code class="block">nginx&nbsp;-p&nbsp;/home/agentzh/test/<br/>
</code><p>For this server, its "configure prefix" becomes <code>/home/agentzh/test/</code> and its "document root" becomes <code>/home/agentzh/test/html/</code>. The "configure prefix" not only determines "document root", it actually determines the way many relational path resolutes to absolute path in Nginx configuration. We will encounter many examples which reference "configure prefix".
</p>
<p>In fact there is a simple way of telling current "document root", which is to request a non-existed file, Such as:
</p>
<code class="block">$&nbsp;curl&nbsp;'http://localhost:8080/blah-blah.txt'<br/>
&lt;html&gt;<br/>
&lt;head&gt;&lt;title&gt;404&nbsp;Not&nbsp;Found&lt;/title&gt;&lt;/head&gt;<br/>
&lt;body&nbsp;bgcolor=&quot;white&quot;&gt;<br/>
&lt;center&gt;&lt;h1&gt;404&nbsp;Not&nbsp;Found&lt;/h1&gt;&lt;/center&gt;<br/>
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br/>
&lt;/body&gt;<br/>
&lt;/html&gt;<br/>
</code><p>Naturally, the <code>404</code> error page is returned. Again when we check Nginx error log, we shall have following error message:
</p>
<code class="block">[error]&nbsp;9364#0:&nbsp;*1&nbsp;open()&nbsp;&quot;/home/agentzh/test/html/blah-blah.txt&quot;&nbsp;failed&nbsp;(2:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory)<br/>
</code><p>The error message is printed by module <code>ngx_static</code>, since it cannot find a file <code>blah-blah.txt</code> in its corresponding path. And because the error message contains the absolute path, which <code>ngx_static</code> attempts to open with, it's quite obvious that current "document root" is <code>/home/agentzh/test/html/</code>.
</p>
<p>Many newbies might take it for granted that error <code>404</code> is caused when the needed <code>location</code> does not exist. The former example tells us, <code>404</code> error could be returned even if the needed <code>location</code> is configured and matched. This is because error <code>404</code> means the non-existence of an abstract "resource", not the specific <code>location</code>.
</p>
<p>Another frequent mistake is missing the command for phase <code>content</code>, when they actually don't expect the default static modules to come into play,for example:
</p>
<code class="block">location&nbsp;/auth&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;a&nbsp;lot&nbsp;of&nbsp;Lua&nbsp;code&nbsp;omitted&nbsp;here...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;';<br/>
}<br/>
</code><p>Apparently,  only commands for phase <code>access</code> are given for <code>/auth</code>, which is  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>. And it has no commands for phase <code>content</code>. So when <code>/auth</code> is requested, the Lua code specified in <code>access</code> phase will execute, then the static resource will be served in phase <code>content</code> by module <code>ngx_static</code>. Since it actually looks for the file <code>/auth</code> on the disk normally it dumps a <code>404</code> error unless we are luckily and file <code>/auth</code> is created on the corresponding path. So the thumb of rule, when error <code>404</code> is encountered under no static resource circumstances, we shall first check if the <code>location</code> has properly configured its commands for phase <code>content</code>, the commands can be  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> and  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> etc. In fact, Nginx error log <code>error.log</code> could only give very confusing message for the case. As the ones below, which is found for the above example:
</p>
<code class="block">[error]&nbsp;9364#0:&nbsp;*1&nbsp;open()&nbsp;&quot;/home/agentzh/test/html/auth&quot;&nbsp;failed&nbsp;(2:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory)<br/>
</code></article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder08">Nginx directive execution order (08) <a class="anchor" href="#02-nginxdirectiveexecorder08">&#61532;</a></h1>
<p>So far we have addressed in detail <code>rewrite</code>, <code>access</code> and <code>content</code>, which are also the most frequently encountered phases in Nginx request processing. We have learnt many Nginx modules and their commands that execute in those phases, and it's clear to us that the commands' execution order is directly decided by the phase they are running in. Understanding the phase is our keynote for correct configuration which orchestrates various Nginx modules. Therefore let's cover the rest phases we've not met.
</p>
<p>As mentioned in <a href="#02-NginxDirectiveExecOrder01">(01)</a>, altogether there can be 11 phases when Nginx handles a request. In their execution order the phases are <code>post-read</code>, <code>server-rewrite</code>, <code>find-config</code>, <code>rewrite</code>, <code>post-rewrite</code>, <code>preaccess</code>, <code>access</code>, <code>post-access</code>, <code>try-files</code>, <code>content</code>, and finally <code>log</code>.
</p>
<p>Phase <code>post-read</code> is the very first, commands registered in this phase execute right after Nginx has processed the request headers. Similar to phase <code>rewrite</code> we've learnt earlier, <code>post-read</code> supports hooks by Nginx modules. Built-in module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> is an example, it hooks its handler in <code>post-read</code> phase, and forcefully rewrite the request's original address as the value of a specific request header. The following case illustrates  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> module and its commands  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a>,  <a href="http://wiki.nginx.org/HttpRealIpModule#real_ip_header" target="_blank">real_ip_header</a>.
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;&nbsp;&nbsp;X-My-IP;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$addr&nbsp;$remote_addr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;from:&nbsp;$addr&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>The configuration tells Nginx to forcefully rewrite the original address of every request coming from <code>127.0.0.1</code> to be the value of the request header <code>X-My-IP</code>. Meanwhile it uses the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> to output the request's original address, so that we know if the rewrite is successful.
</p>
<p>First we send a request to <code>/test</code> from localhost:
</p>
<code class="block">$&nbsp;curl&nbsp;-H&nbsp;'X-My-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br/>
from:&nbsp;1.2.3.4<br/>
</code><p>The test utilizes <code>-H</code> option provided by curl, the option incorporates an extra HTTP header <code>X-My-IP: 1.2.3.4</code> in the request. As we can tell, variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> has become <code>1.2.3.4</code> in <code>rewrite</code> phase, the value comes from the request header <code>X-My-IP</code>. So when does Nginx rewrite the request's original address ? yes it's in the <code>post-read</code> phase. Since phase <code>rewrite</code> is far behind phase <code>post-read</code>, when command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> reads variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a>, its value has already been rewritten in <code>post-read</code> phase.
</p>
<p>If however, the request sent from localhost to <code>/test</code> does not have a <code>X-My-IP</code> header or the header value is an invalid IP address, Nginx will not modify the original address. For example:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/test<br/>
from:&nbsp;127.0.0.1<br/>
<br/>
$&nbsp;curl&nbsp;-H&nbsp;'X-My-IP:&nbsp;abc'&nbsp;localhost:8080/test<br/>
from:&nbsp;127.0.0.1<br/>
</code><p>If a request is sent from another machine to <code>/test</code>, it original address won't be overwritten by Nginx either, even if it has a perfect <code>X-My-IP</code> header. It is because our previous case marks explicitly with command  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a>, that the rewriting only occurs for the requests coming from <code>127.0.0.1</code>. This filtering mechanism protect Nginx from malicious requests sent by untrusted sources. As you might have expected, command  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a> can designate a IP subnet (by using CIDR notation introduced earlier in <a href="#02-NginxDirectiveExecOrder03">(03)</a>). Besides, command  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a> can be used multiple times so that we can setup multiple trusted sources, below is an example:
</p>
<code class="block">set_real_ip_from&nbsp;10.32.10.5;<br/>
set_real_ip_from&nbsp;127.0.0.0/24;<br/>
</code><p>You might be asking, what's the benefit module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> brings to us? Why would we rewrite a request's original address ? The answer is: when the request has come through one or more HTTP proxies, the module becomes very handy. When a request is forwarded by a proxy, its original address will become the proxy server's IP address, consequently Nginx and the services running on it will no longer have the actual source. However, we could let proxy server record the original address in a specific header (such as <code>X-My-IP</code>) and recover it in Nginx, so that its subsequent processing (and the services running on Nginx) will take the request as if it comes right from its original address and the proxies in between are transparent. For this exact purpose, module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> needs hook handlers in the first phase, the <code>post-read</code> phase, so the rewriting occurs as early as possible.
</p>
<p>Behind <code>post-read</code> is the <code>server-rewrite</code> phase. We briefly mentioned in <a href="#02-NginxDirectiveExecOrder02">(02)</a>, when module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> and its commands are configured in <code>server</code> directive, they basically execute in <code>server-rewrite</code> phase. We have an example below:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$b&nbsp;&quot;$a,&nbsp;world&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br/>
}<br/>
</code><p>Attention the <code>set $a hello</code> statement is put in <code>server</code> directive, so it runs in <code>server-rewrite</code> phase, which runs earlier than <code>rewrite</code> phase. Therefore statement <code>set $b "$a, world'"</code> in <code>location</code> directive is executed afterwards and it obtains the correct $a value:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/test<br/>
hello,&nbsp;world<br/>
</code><p>Since phase <code>server-rewrite</code> executes later than <code>post-read</code> phase, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> in <code>server</code> directive always runs later than module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a>, which rewrites the request's original address, example:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$addr&nbsp;$remote_addr;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;&nbsp;&nbsp;X-Real-IP;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;from:&nbsp;$addr&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Send request to <code>/test</code> we have:
</p>
<code class="block">$&nbsp;curl&nbsp;-H&nbsp;'X-Real-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br/>
from:&nbsp;1.2.3.4<br/>
</code><p>Again, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> is written in front of commands of  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a>, its actual execution is only afterwards. So when command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> assigns variable <code>$addr</code> in <code>server-rewrite</code> phase, the variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> has been overwritten.</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder09">Nginx directive execution order (09) <a class="anchor" href="#02-nginxdirectiveexecorder09">&#61532;</a></h1>
<p>Right after <code>server-rewrite</code> is the phase <code>find-config</code>. This phase does not allow Nginx modules to register their handlers, instead it is a phase when Nginx core matches the current request to the <code>location</code> directives. It means a request is not catered by any <code>location</code> directive until it reaches <code>find-config</code>. Apparently, for phases like <code>post-read</code> and <code>server-rewrite</code>, the effective commands are those which get specified only in <code>server</code> directives and their outer directives, because the two phases are executed earlier than <code>find-config</code>. This explains that commands of module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> are executed in phase <code>server-rewrite</code> only if they are written within <code>sever</code> directive. Similarly, the former examples configure the commands of module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> in <code>server</code> directive to make sure the handlers registered in <code>post-read</code> phase could function correctly.
</p>
<p>As soon as Nginx matches a <code>location</code> directive in the <code>find-config</code> phase, it prints a debug log in the error log file. Let's check following example:
</p>
<code class="block">location&nbsp;/hello&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;hello&nbsp;world&quot;;<br/>
}<br/>
</code><p>If Nginx enables the "debug log", a debug log can be captured in file <code>error.log</code> whenever interface <code>/hello</code> is requested.
</p>
<code class="block">$&nbsp;grep&nbsp;'using&nbsp;config'&nbsp;logs/error.log<br/>
[debug]&nbsp;84579#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;&quot;/hello&quot;<br/>
</code><p>For the purpose of convenience, the log's time stamp has been omitted.
</p>
<p>After phase <code>find-config</code>, it is our old buddy <code>rewrite</code>. Since Nginx already matches the request to a specific <code>location</code> directive, starting from this phase, commands written within <code>location</code> directives are becoming effective. As illustrated earlier, commands of module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> are executed in <code>rewrite</code> phase when they are written in <code>location</code> directives. Likewise, commands of module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> and module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> ( <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> and  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a>) are also executed in phase <code>rewrite</code>.
</p>
<p>After <code>rewrite</code>, it is the <code>post-rewrite</code> phase. Just like <code>find-config</code>, this phase does not allow Nginx modules to register their handlers either, instead it carries out the needed "internal redirects" by Nginx core (if this has been requested in <code>rewrite</code> phase). We have addressed the "internal jump" concept in <a href="#02-NginxDirectiveExecOrder02">(02)</a>, and demonstrated how to issue the "internal redirect" with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> or command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>. However, let's focus on command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> for the moment since command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> is executed in <code>content</code> phase and becomes irrelevant to <code>post-rewrite</code>, the former draws greater interest because it executes in <code>rewrite</code> phase. Back to our example in <a href="#02-NginxDirectiveExecOrder02">(02)</a>:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/bar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;a&nbsp;=&nbsp;[$a]&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>The command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> found in directive <code>location /foo</code>, rewrites the URI of current request as <code>/bar</code> unconditionally, meanwhile, it issues an "internal redirect" and execution continues from <code>location /bar</code>. What ultimately intrigues us, is the magical bits and pieces of "internal redirect" mechanism, "internal redirect" effectively rewinds our processing of current request back to the <code>find-config</code> phase, so that the <code>location</code> directives can be matched again to the request URI, which usually has been rewritten. Just like our example, whose URI is rewritten as <code>/bar</code> by command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>, the <code>location /bar</code> directive is matched and execution repeats the <code>rewrite</code> phase thereafter.
</p>
<p>It might not be obvious, that the actual act of rewinding to <code>find-config</code> does not occur in <code>rewrite</code> phase, instead it occurs in the following <code>post-rewrite</code> phase. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> in the former example, simply requests Nginx to issue an "internal redirect" in its <code>post-rewrite</code> phase. This design is usually questioned by Nginx beginners and they tend to come up with an idea to execute the "internal jump" directly by command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>. The answer however, is fairly simple. The design allows URI be rewritten multiple times in the <code>location</code> directive,which is matched at the very beginning. Such as:
</p>
<code class="block">location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/bar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/baz;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;foo;<br/>
}<br/>
<br/>
location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;bar;<br/>
}<br/>
<br/>
location&nbsp;/baz&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;baz;<br/>
}<br/>
</code><p>The request URI has been rewritten twice in <code>location /foo</code> directive: firstly it becomes <code>/bar</code>, secondly it becomes <code>/baz</code>. As the net effect of both  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> statements, "internal redirect" occurs only once in <code>post-rewrite</code> phase. If it would have executed the "internal redirect" at the first URI rewrite, the second would have no chance to be executed since processing would have left current <code>location</code> directive. To prove this we send a request to <code>/foo</code>:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/foo<br/>
baz<br/>
</code><p>It can be asserted from the output, the actual jump is from <code>/foo</code> to <code>/baz</code>. We could further prove this by enabling Nginx "debug log" and interrogate the debug log generated in <code>find-config</code> phase for the matched:
</p>
<code class="block">$&nbsp;grep&nbsp;'using&nbsp;config'&nbsp;logs/error.log<br/>
[debug]&nbsp;89449#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;&quot;/foo&quot;<br/>
[debug]&nbsp;89449#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;&quot;/baz&quot;<br/>
</code><p>Clearly, for the specific request, Nginx only matches two <code>location</code> directives: <code>/foo</code> and <code>/baz</code>, and "internal jump" occurs only once.
</p>
<p>Quite obviously, if command <code>ngx_rewrite/rewrite</code> is used to rewrite the request URI in <code>server</code> directive, there won't be any "internal redirects", this is because the URI rewrite is happening in <code>server-rewrite</code> phase, which gets executed earlier than <code>find-config</code> phase that matches in between the <code>location</code> directives. We can check the example below:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^/foo&nbsp;/bar;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;foo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;bar;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>In the example, every request whose URI starts with <code>/foo</code> gets its URI rewritten as <code>/bar</code>. The rewriting occurs in <code>server-rewrite</code> phase, and the request has never been matched to any <code>location</code> directive. Only afterwards Nginx executes the matches in <code>find-config</code> phase. So if we send a request to <code>/foo</code>, <code>location /foo</code> never gets matched because when the match occurs in <code>find-config</code> phase, the request URI has been rewritten as <code>/bar</code>. So <code>location /bar</code> is the one and the only one matched directive. Actual output illustrates this:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/foo<br/>
bar<br/>
</code><p>Again let's check Nginx "debug log":
</p>
<code class="block">$&nbsp;grep&nbsp;'using&nbsp;config'&nbsp;logs/error.log<br/>
[debug]&nbsp;92693#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;&quot;/bar&quot;<br/>
</code><p>As we can tell, Nginx altogether finishes once the <code>location</code> match, and there is no "internal redirect".</p>
</article>
<article>
    <h1 class="con-title" id="02-nginxdirectiveexecorder10">Nginx directive execution order (10) <a class="anchor" href="#02-nginxdirectiveexecorder10">&#61532;</a></h1>
<p>After <code>post-rewrite</code>, it is the <code>preaccess</code> phase. Just as its name implies, the phase is called <code>preaccess</code> simply because it is executed right before <code>access</code> phase.
</p>
<p>Built-in module  <a href="http://wiki.nginx.org/HttpLimitReqModule" target="_blank">ngx_limit_req</a> and  <a href="http://wiki.nginx.org/HttpLimitZoneModule" target="_blank">ngx_limit_zone</a> are executed in this phase. The former limits the number of requests per hour/minute, and the latter limits the number of simultaneous requests. We will be discussing them more thoroughly afterwards.
</p>
<p>Actually, built-in module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> registers its handler in <code>preaccess</code> as well. You might need to ask then: "why do it again? Did it register its handlers in <code>post-read</code> phase already". Before the answer is uncovered let's study following example:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;X-Real-IP;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;from:&nbsp;$remote_addr&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>Comparing to the earlier example, the major difference is that commands of module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> are written in a specific <code>location</code> directive. As we have learnt before, Nginx matches its <code>location</code> directives in <code>find-config</code> phase, which is far behind <code>post-read</code>, hence the request has nothing to do with commands written in any <code>location</code> directive in <code>post-read</code> phase. Back to our example, it is exactly the case where commands are written in a <code>location</code> directive and module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> won't carry out any rewrite of the remote address, because it is not instructed as such in <code>post-read</code> phase.
</p>
<p>What if we do need the rewrite? To help resolve the issue, module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> registers its handlers in <code>preaccess</code> again, so that it is given the chance to execute in a <code>location</code> directive. Now the example runs as we would've expected:
</p>
<code class="block">$&nbsp;curl&nbsp;-H&nbsp;'X-Real-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br/>
from:&nbsp;1.2.3.4<br/>
</code><p>Be really careful though, module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> could easily be misused, as our following example illustrates:
</p>
<code class="block">server&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;X-Real-IP;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$addr&nbsp;$remote_addr;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;from:&nbsp;$addr&quot;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</code><p>In the example, we introduces a variable <code>$addr</code>, to which the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> is saved in <code>rewrite</code> phase. The variable is then used in the output. Slow down right here and you might have noticed the issue, phase <code>rewrite</code> occurs earlier than <code>preaccess</code>, so variable assignment actually happens before module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> has the chance to rewrite the remote address in <code>preaccess</code> phase. The output proves our observation:
</p>
<code class="block">$&nbsp;curl&nbsp;-H&nbsp;'X-Real-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br/>
from:&nbsp;127.0.0.1<br/>
</code><p>The output gives the actual remote address (not the rewritten one) Again Nginx "debug log" helps assert it too:
</p>
<code class="block">$&nbsp;grep&nbsp;-E&nbsp;'http&nbsp;script&nbsp;(var|set)|realip'&nbsp;logs/error.log<br/>
[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;&quot;127.0.0.1&quot;<br/>
[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$addr<br/>
[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;&quot;1.2.3.4&quot;<br/>
[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;0100007F&nbsp;FFFFFFFF&nbsp;0100007F<br/>
[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;&quot;127.0.0.1&quot;<br/>
</code><p>Among the logs, the first line writes:
</p>
<code class="block">[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;&quot;127.0.0.1&quot;<br/>
</code><p>The log is generated when variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> is fetched by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>, string <code>"127.0.0.1"</code> is the fetched value.
</p>
<p>The second line writes:
</p>
<code class="block">[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$addr<br/>
</code><p>It indicates Nginx assigns value to variable <code>$addr</code>.
</p>
<p>For the following two lines:
</p>
<code class="block">[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;&quot;1.2.3.4&quot;<br/>
[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;0100007F&nbsp;FFFFFFFF&nbsp;0100007F<br/>
</code><p>They are generated when module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> rewrites the remote address in <code>preaccess</code> phase. As we can tell, the new address becomes <code>1.2.3.4</code> as expected but it happens only after the variable assignment and that's already too late.
</p>
<p>Now the last line:
</p>
<code class="block">[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;&quot;127.0.0.1&quot;<br/>
</code><p>It is generated when command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> outputs variable <code>$addr</code>, clearly the value is the original remote address, not the rewritten one.
</p>
<p>Some people might come up with a solution immediately:" what if module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> registers its handlers in <code>rewrite</code> phase instead, not in <code>preacccess</code> phase ?" The solution however is, not necessarily correct. This is because module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> registers its handlers in <code>rewrite</code> phase too, and we have learnt in <a href="#02-NginxDirectiveExecOrder02">(02)</a> that the execution order, under the circumstances, can not be guaranteed, so there is a good chance that module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> still executes its commands after command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>.
</p>
<p>Always we have the backup option: instead of <code>preaccess</code>, try use  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> module in <code>server</code> directive, it bypasses the bothersome situations encountered above.
</p>
<p>After phase <code>preaccess</code>, it is another old friend, the <code>access</code> phase. As we've learnt, built-in module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>, 3rd party module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> and 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> ( <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>) have their commands executed in this phase.
</p>
<p>After phase <code>access</code>, it is the <code>post-access</code> phase. Again as the name implies, we can easily spot that the phase is executed right after <code>access</code> phase. Similar to <code>post-rewrite</code>, the phase does not allow Nginx module to register their handlers, instead it runs a few tasks by Nginx core, among them, primarily is the  <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank">satisfy</a> functionality, provided by module <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a>.
</p>
<p>When multiple Nginx module execute their commands in <code>access</code> phase, command  <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank">satisfy</a> controls their relationships in between. For example, both module A and module B register their access control handlers in <code>access</code> phase, we may have two working modes, one is to let access when both A and B pass their control, the other is to let access when either A or B pass their control. The first one is called <code>all</code> mode ("AND" relation), the second one is called <code>any</code> mode ("OR" relation) By default, Nginx uses <code>all</code> mode, below is an example:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;satisfy&nbsp;all;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'ngx.exit(ngx.OK)';<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;something&nbsp;important;<br/>
}<br/>
</code><p>Under <code>/test</code> directive, both  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> and  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> are used, so we have two modules monitoring access in <code>access</code> phase. Specifically, statement <code>deny all</code> tells module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> to rejects all access, whereas statement <code>access_by_lua 'ngx.exit(ngx.OK)'</code> allows all access. When <code>all</code> mode is used with command  <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank">satisfy</a>, it means to let access only if every module allows access. Since module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> always rejects in our case, the request is rejected:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/test<br/>
&lt;html&gt;<br/>
&lt;head&gt;&lt;title&gt;403&nbsp;Forbidden&lt;/title&gt;&lt;/head&gt;<br/>
&lt;body&nbsp;bgcolor=&quot;white&quot;&gt;<br/>
&lt;center&gt;&lt;h1&gt;403&nbsp;Forbidden&lt;/h1&gt;&lt;/center&gt;<br/>
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br/>
&lt;/body&gt;<br/>
&lt;/html&gt;<br/>
</code><p>Careful readers might find following error log in the Nginx error log file:
</p>
<code class="block">[error]&nbsp;6549#0:&nbsp;*1&nbsp;access&nbsp;forbidden&nbsp;by&nbsp;rule<br/>
</code><p>If however, we change the <code>satisfy all</code> statement to <code>satisfy any</code>.
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;satisfy&nbsp;any;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'ngx.exit(ngx.OK)';<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;something&nbsp;important;<br/>
}<br/>
</code><p>The outcome is completely different:
</p>
<code class="block">$&nbsp;curl&nbsp;localhost:8080/test<br/>
something&nbsp;important<br/>
</code><p>The request is allowed to access. Because overall access is allowed whenever one module passes the control in <code>any</code> mode. In our example, module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and its command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> always allow the access.
</p>
<p>Certainly, if every module rejects the access in the <code>satisfy any</code> circumstances, the request will be rejected:
</p>
<code class="block">location&nbsp;/test&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;satisfy&nbsp;any;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'ngx.exit(ngx.HTTP_FORBIDDEN)';<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;something&nbsp;important;<br/>
}<br/>
</code><p>Now request to <code>/test</code> will encounter <code>403 Forbidden</code> error page. In the process, the "OR" relation of access control of each <code>access</code> module, is implemented in <code>post-access</code>.
</p>
<p>Please note that this example requires at least  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> 0.5.0rc19 or later; earlier versions cannot work with the <code>satisfy any</code> statement.</p>
</article>
</section>
<script>
function init_back_top() {
    function _fn() {
        var t = Math.max(document.documentElement.scrollTop, document.body.scrollTop);
        if (t > 5) {
            if (! show) {
                show = true;
                r.className = 'backtop-box-show';
            }
        } else {
            if (show) {
                show = false;
                r.className = '';
            }
        }
    }

    var r = document.createElement('div');
    document.body.appendChild(r);
    r.innerHTML = '<div class="backtop-box"><b title="Jump to Top of Page">Top</b></div>';

    var show = false;
    r.onclick = function() {
        window.scrollTo(0, 0);
    };

    window.onscroll = _fn;
    window.onresize = _fn;
}

init_back_top();
</script>
</body></html>